\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}
%\documentclass[a4paper,UKenglish,cleveref, autoref, anonymous, thm-restate]{lipics-v2021}
%
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository% \usepackage[numbers]{natbib}

\bibliographystyle{plainurl}% the mandatory bibstyle

\usepackage{multirow}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{makecell}
\usepackage[table]{xcolor}
%\usepackage{arydshln}
%\newcommand\VRule[1][\arrayrulewidth]{\vrule width #1}
\usepackage[noend]{algorithm2e}

\usepackage{tikz}
% TikZ libraries
\usetikzlibrary{myautomata}
\usetikzlibrary{fit, backgrounds}
\usetikzlibrary{extshapes}

\usepackage{pgfplots}
\pgfplotsset{compat=newest}

%{{{ (La)TeX definitions

\newcommand{\Nset}{{\mathbb{N}_0}}
\newcommand{\todo}[1]{\marginpar{\textcolor{red}{#1}}}
%\def\Inf{\ensuremath{\mathsf{Inf}}}
%\def\Fin{\ensuremath{\mathsf{Fin}}}
\DeclareMathOperator{\Inf}{\mathsf{Inf}}
\DeclareMathOperator{\Fin}{\mathsf{Fin}}
\newcommand{\minf}{\mathit{inf}}
\newcommand{\mks}{\mathit{mks}}
%\newcommand{\oM}{\widehat{M}}
\newcommand{\oM}{N}
\newcommand{\rem}{\mathit{nm}}
\newcommand{\mcycle}{\mathit{cycle}}
\newcommand{\msat}{\mathit{satisfies}}
\newcommand{\Te}{T_{\vec{e}}}
% \newcommand{\pre}{{\leftarrow\!\!S}}
% \newcommand{\post}{{S\!\!\rightarrow}}
\newcommand{\pre}{{S_\mathit{pre}}}
\newcommand{\post}{{S_\mathit{post}}}
\def\false{\mathit{false}}
\def\true{\mathit{true}}
\newcommand{\mA}{\mathcal{A}}
\newcommand{\mB}{\mathcal{B}}

\newcommand{\telatko}{\texttt{telatko}\xspace}

%}}}

%{{{ title and authors

\title{Reducing Acceptance Marks in Emerson-Lei Automata by QBF-solving}
\author{Tereza Schwarzov\'{a}}{Faculty of Informatics, Masaryk University, Brno, Czech Republic}{xschwar3@mail.muni.cz}{}{}
\author{Jan Strej\v{c}ek}{Faculty of Informatics, Masaryk University, Brno, Czech Republic}{strejcek@fi.muni.cz}{https://orcid.org/0000-0001-5873-403X}{}
\author{Juraj Major}{Faculty of Informatics, Masaryk University, Brno, Czech Republic}{major@fi.muni.cz}{}{}
\authorrunning{T. Schwarzov\'{a}, J. Strej\v{c}ek, and J. Major}
\Copyright{Tereza Schwarzov\'{a}, Jan Strej\v{c}ek, and Juraj Major}
\ccsdesc[500]{Theory of computation~Logic}
\ccsdesc[500]{Theory of computation~Automata over infinite objects}
\keywords{Emerson-Lei automata, TELA, automata reduction, QBF, telatko}
\funding{This work has been supported by the Czech Science Foundation grant GA19-24397S.}

%}}}

\begin{document}

\maketitle

%{{{ abstract

\begin{abstract}
  \emph{Transition-based Emerson-Lei automata (TELA)} became a popular
  formalism that generalizes many traditional kinds of automata over
  infinite words including Büchi, co-Büchi, Rabin, Streett, and parity
  automata. Transitions in a TELA are labelled with acceptance marks
  and its accepting formula is a positive Boolean combination of terms
  saying that a particular mark has to be visited infinitely or
  finitely often. % in an accepting run.
  Algorithms processing these automata are often very sensitive to the
  number of %different
  acceptance marks. We introduce a new technique reducing the number
  of %different
  acceptance marks in TELA with use of \emph{quantified Boolean
    formulas (QBF)}.
  % : if a constructed QBF formula is satisfiable then
  % its model encodes an equivalent accepting formula with less
  % acceptance marks.
  In fact, we present three formula constructions
  % trading speed for higher reduction efficiency.
  with increasing reduction potential and formula complexity, and thus
  also decreasing speed of their satisfiability solving. We evaluated
  our reduction technique on TELA produced by state-of-the-art tools
  of the libraries Owl and Spot and by the tool \texttt{ltl3tela}. The
  technique reduced some acceptance marks in automata produced by all
  the tools. On automata with more than one acceptance mark produced
  by tools Delag and Rabinizer~4 of the Owl library, our technique reduced
  reduced 29.1\% and 38.5\% of acceptance marks, respectively.
  % The achieved
  % reduction of acceptance marks on automata produced by tools of the Owl library was
  % between 25 and 40\%.
\end{abstract}

%}}}

%{{{ introduction

\section{Introduction}

% Automata over infinite words (also known as $\omega$-automata) are now
% used in specification, verification, analysis, monitoring, and
% synthesis of various systems with infinite behaviour. The first and
% the most common kind of $\omega$-automata is Büchi
% automaton~\cite{buchi.60.clmps} introduced in 1960. As deterministic
% Büchi automata are less expressive than nondeterministic ones,
% deterministic $\omega$-automata are typically considered with other
% acceptance condition like Rabin, Streett, Muller, or parity. In 1987,
% Emerson and Lei~\cite{emerson.87.scp} introduced $\omega$-automata
% where the acceptance condition can be an arbitrary combination of
% acceptance primitives saying that a certain set of states should be
% visited finitely often or infinitely often. In 2015, the same kind of
% acceptance condition was implemented in the \emph{Hanoi omega-automata
%   format (HOAF)}~\cite{babiak.15.cav}, with the difference that finiteness 

Automata over infinite words like Büchi, Rabin, Streett, or parity
automata play a crucial role in many algorithms related to the
concurrency theory. In particular, they are used in specification,
verification, analysis, monitoring, and synthesis of various systems
with infinite behaviour. In 1987, Emerson and
Lei~\cite{emerson.87.scp} introduced automata over infinite words
where acceptance conditions are arbitrary combinations of acceptance
primitives saying that a certain set of states should be visited
finitely often or infinitely often. In 2015, the same kind of
acceptance condition was described in the \emph{Hanoi omega-automata
  format (HOAF)}~\cite{babiak.15.cav}. The only difference is that the
acceptance primitives talk about finitely or infinitely often visited
acceptance marks rather than sets of states.  Acceptance marks are
placed on transitions and each mark identifies the set of transitions
containing this mark. Hence, these automata are called
\emph{transition-based Emerson-Lei automata (TELA)} and they
generalize many traditional kinds of automata over infinite words
including Büchi, co-Büchi, Rabin, Streett, and parity automata.

TELA have attracted a lot of attention during the last five years.
Their popularity comes probably from the fact that these automata can
often use less states than equivalent automata with simpler acceptance
conditions. Further, algorithms handling TELA can automatically handle
all automata with traditional acceptance conditions. TELA can be
obtained for example by translating LTL formulas by \texttt{ltl2dela}
(known as Delag)~\cite{muller.17.gandalf},
\texttt{ltl3tela}~\cite{major.19.atva}, \texttt{ltl2dgra} (known as
Rabinizer~4)~\cite{kretinsky.18.cav}, or \texttt{ltl2tgba} which is a
part of the Spot library~\cite{duret.16.atva2}.  There are also
algorithms processing these automata, for example the emptiness
check~\cite{baier.19.atva} or translation of TELA to parity
automata~\cite{renkin.20.atva,casares.22.tacas}.

Algorithms processing TELA are often sensitive to the number of
acceptance marks more than to other parts of the automaton. For
example, the transformation of TELA to parity automata based on
\emph{color appearance record}~\cite{renkin.20.atva} transforms a TELA
with $s$ states and $m$ acceptance marks into a parity automaton with
up to $s\cdot m!$ states. Further, the emptiness
check~\cite{baier.19.atva} is exponential in the number of acceptance
marks that appear in acceptance primitives saying that a mark has to
be visited finitely often, while it is only polynomial in other
measures of the input automaton.

The number of acceptance marks can be algorithmically reduced to one
as every TELA can be transformed to an equivalent Büchi automaton
(this can be easily done for example by Spot~\cite{duret.16.atva2}),
but this reduction is paid by dramatic changes of state-space: the
number of states can increase exponentially in the number of
acceptance marks and some important structural properties like
determinism can be lost. This motivates our study of a technique
reducing the number of acceptance marks without altering the structure
of the automaton.

We present such a technique heavily based on \emph{quantified Boolean
  formulas (QBF)}. For a given TELA and parameters $k,n$, it produces
a QBF formula which is satisfiable if and only if there exists an
automaton with the same structure, $n$ acceptance marks, an acceptance
formula in disjunctive normal form with $k$ clauses, and the same set
of accepting runs as the original automaton. The placement of the
marks on transitions and the acceptance formula can be obtained from a
model of the formula. Besides this formula, we describe also the
construction of two simpler formulas such that their satisfiability
implies the existence of an automaton with the same structure, $n$
acceptance marks, and the same set of accepting runs, but not vice
versa.

We have implemented our reduction technique in a tool called
\telatko. We show that the tool can reduce acceptance marks in
automata produced by Delag~\cite{muller.17.gandalf},
Rabinizer~4~\cite{kretinsky.18.cav} (both included in the Owl library),
Spot~\cite{duret.16.atva2}
and \texttt{ltl3tela}~\cite{major.19.atva}.  While the reduction is relatively
modest on TELA produced by \texttt{ltl3tela} and Spot,
it is substantial on automata produced by the tools of the Owl library.

\paragraph*{Related results}
There is a simple technique~\cite{babiak.13.spin} reducing the number
of acceptance marks in \emph{transition-based genealised Büchi
  automata (TGBA)} without changing its structure. We are not aware
about any existing research aimed at simplification of acceptance
formulas of TELA or reduction of the number of its acceptance marks
without increasing the number of states. There exists only a SAT-based
approach that transforms a deterministic TELA automaton to an
equivalent automaton with a given acceptance condition and a given
number of states~\cite{baarir.15.lpar} (if such an automaton
exists). Further, there are some SAT-based approaches aimed to reduce
the number of states of automata over infinite words. More preceisely,
there are reductions designed for nondeterministic Büchi
automata~\cite{ehlers.10.spin}, deterministic Büchi
automata~\cite{ehlers.10.sat}, and deterministic generalized Büchi
automata~\cite{baarir.14.forte}. Note that these techniques are
usually very slow and their authors typically suggest to use them only
for specific purposes like looking for cases where some automata
construction can be improved.

Casares, Colcombet, and Fijalkow very recently introduced a structure
called \emph{alternating cycle decomposition
  (ACD)}~\cite{casares.21.icalp} which compactly represents the
information about all accepting and non-accepting automata cycles. We
expect that ACD could potentialy be used to reduce the number of
acceptance marks or to simplify the acceptance condition. However,
such a reduction is not obvious.
%Moreover, the construction of ACD seems to be computationally expensive.

\paragraph*{Structure of the paper} The next section introduces basic
terms used in the paper. Section~\ref{sec:qbf} explains the
construction of three mentioned QBF formulas. The reduction algorithm
based on these formulas is presented in
Section~\ref{sec:algo}. Section~\ref{sec:implementation} describes our
tool \telatko implemening the reduction technique.
Experimental results are shown in
Section~\ref{sec:experiments}. Finally, Section~\ref{sec:conclusion}
suggests other applications of our QBF-based reduction technique and
closes the paper.

%}}}
%{{{ preliminaries

\section{Preliminaries}\label{sec:prelim}

In this section we recall the basic terms around TELA and QBF.

\begin{definition}[TELA]
  A \emph{transition-based Emerson-Lei automaton (TELA)} is a tuple
  $\mA =(Q,M,\Sigma,q_I,\delta,\varphi)$, where
  \begin{itemize}
  \item $Q$ is a finite set of \emph{states},
  \item $M$ is a finite set of \emph{acceptance marks},
  \item $\Sigma$ is a finite \emph{alphabet},
  \item $q_I\in Q$ is an \emph{initial state},
  \item $\delta \subseteq Q \times \Sigma \times 2^{M} \times Q$ is a
    \emph{transition relation}, and
  \item $\varphi$ is the \emph{acceptance condition} constructed
    according to the following abstract syntax equation, where $m$
    ranges over $M$.
    $$\varphi ::= \true \mid \false \mid \Inf m \mid \Fin m \mid \left( \varphi \land \varphi \right) \mid \left( \varphi \lor \varphi \right)$$
\end{itemize}
\end{definition}

A tuple $t=(p,a,M',q)\in\delta$ is the \emph{transition} leading from
state $p$ to state $q$ labelled with $a$ and acceptance marks $M'$.
The set $M'$ is also refered by $\mks(t)$. For a set of transitions
$T\subseteq\delta$, let $\mks(T)=\bigcup_{t\in T}\mks(t)$ denote the
set of marks that appear on transitions in $T$.
% of various objects:
% \begin{itemize}
% \item for a transition $t=(p,a,M',q)\in\delta$, $\mks(t)$ denotes the set $M'$,
% \item for a set $T\subseteq\delta$ of transitions,
%   $\mks(T)=\bigcup_{t\in T}\mks(t)$ denotes the set of marks that appear on
%   transitions in $T$,
% \item for a run $\pi$, $\mks(\pi)=\mks(\minf(\pi))$ denotes the set of
%   marks that occur in infinitely many transitions of run $\pi$.
% \end{itemize}

A \emph{run} $\pi$ of $\mA$ over an infinite word
$u = u_{0}u_{1}u_{2}\ldots \in \Sigma^{\omega}$ is an infinite sequence
of adjacent transitions
$\pi=(q_0,u_0,M_0,q_1)(q_1,u_1,M_1,q_2)\ldots\in\delta^{\omega}$ where
$q_0=q_I$. Let $\minf(\pi)$ denote the set of transitions that appear
infinitely many times in $\pi$. Run $\pi$ is \emph{accepting} iff
$\minf(\pi)$ satisfies the formula $\varphi$, where a set $T$ of
transitions satisfies $\Inf m$ iff $m\in\mks(T)$ and it satisfies
$\Fin m$ iff $m\not\in\mks(T)$. The \emph{language} of automaton $\mA$ is
the set
$L(\mA)=\{u\in \Sigma^{\omega}\mid\textrm{there is an accepting run of
}\mA\textrm{ over }u\}$. Two automata $\mA,\mB$ are \emph{equivalent}
if $L(\mA)=L(\mB)$.
% such that $\mA$ has
% an accepting run over $u$.

An acceptance formula $\varphi$ is in \emph{disjunctive normal formal
  (DNF)} if it is a disjunction of clauses, where each clause is a
conjunction of terms of the form $\Fin m$ or $\Inf m$.  Each
acceptance formula can be transformed into an equivalent formula
in~DNF. Formula $\false$ corresponds to the disjunction of zero
clauses and formula $\true$ corresponds to one clause with zero terms.

A \emph{path} from a state $p$ to a state $q$ is a finite sequence of
adjacent transitions of the form
$\rho=(q_0,u_0,M_0,q_1)(q_1,u_1,M_1,q_2)\ldots(q_{n-1},u_{n-1},M_{n-1},q_n)\in\delta^+$
such that $p=q_0$ and $q=q_n$. A nonempty set of states $S\subseteq Q$
is called a nontrivial \emph{strongly connected component (SCC)} if
for each $p,q\in S$ there is a path from $p$ to $q$. An SCC S is
\emph{maximal} if there is no SCC $S'$ satisfying $S\subsetneq S'$. In
the rest of this paper, SCC always refers to a maximal SCC. Given a
set of states $S\subseteq Q$, let $\delta_S=\delta\cap (S\times \Sigma \times 2^M \times S)$
denote the set of all transitions between states in $S$. Further, for
each mark $m\in M$, let $\delta_m=\{t\in\delta\mid m\in
\mks(t)\}$ denote the set of all transitions
marked with $m$.
% \todo{The sets $\delta_m$ are called \emph{acceptance sets}. Given
% an SCC $S$ and a mark $m\in M$, by $\delta_{S,m}$ we denote the set
% $\delta_{S,m}=\delta_S\cap\delta_m$.}
A set of transitions $T\subseteq\delta$ is called a \emph{cycle} is
there exists a path from a state $p$ to the same state containing each
transition of $T$ at least once and no transition outside
$T$. Finally, we assume that each TELA $\mA$ contains only states $q$
that are reachable from the initial state $q_I$ (i.e., $q=q_I$ or
there is a path from $q_I$ to $q$) as states that are not reachable
from $q_I$ can be eliminated without any impact on $L(\mA)$.

In graphical representation of automata, we often use acceptance marks
$\tacc{1}{1},\tacc{2}{2},\ldots\in M$. Further, an edge 
\begin{tikzpicture}[smallautomaton,baseline=-2pt]
  \node[state] (p) at (0,0) {$p$};
  \node[state] (q) at (1.8,0) {$q$};
  \path [->] (p) edge node[above,pos=.5,overlay] {$a$} node[accset,collacc8, pos=0.65] {k} node[accset,collacc4, pos=0.3] {j} (q);
\end{tikzpicture}
denotes the transition $(p,a,\{\tacc{4}{j},\tacc{8}{k}\},q)\in\delta$. 

\bigskip

\emph{Quantified Boolean formulas (QBF)} are Boolean formulas
extended with universal and existential quantification over
propositional variables. We assume that subformulas of the form
$\forall x.\psi$ and $\exists x.\psi$ do not contain another
quantification of variable $x$ inside $\psi$. The semantics of
$\forall x.\psi$ and $\exists x.\psi$ is given by equivalences
\[
  \begin{array}{rcl}
    \forall x.\psi &~\equiv~& \psi[x\rightarrow\true]~\wedge~\psi[x\rightarrow\false]\\
    \exists x.\psi &~\equiv~& \psi[x\rightarrow\true]~\vee~   \psi[x\rightarrow\false]
  \end{array}
\]
where $\psi[x\rightarrow \rho]$ denotes the formula $\psi$ with all
occurrences of $x$ simultaneously replaced by $\rho$. The equivalences
imply that each QBF can be transformed into an equivalent Boolean
formula. However, the size of this Boolean formula can be exponential
in the size of the original QBF. Let $V$ be the set of all
propositional variables. A mapping $\mu:V\rightarrow\{\true,\false\}$
is a \emph{model} of a QBF formula $\varphi$ iff it is a satisfying
assignment of an equivalent Boolean formula. A QBF formula is
\emph{satisfiable} iff it has a model.

% A QBF $\varphi$ is in the \emph{prenex normal form} if it has the form
% $\varphi = Q_{1}x_{1}...Q_{n}x_{n} . \psi$, where
% $Q_1,\ldots,Q_n \in \{\forall, \exists\}$ and $\psi$ is a Boolean
% formula.

%}}}
%{{{ construction of QBF formulas

\section{Construction of QBF formulas}\label{sec:qbf}

Recall that we aim to reduce the number of acceptance marks in a given
TELA $\mA =(Q,M,\Sigma,q_I,\delta,\varphi)$ without altering its
structure and language. In other words, we are looking for a set $\oM$
of acceptance marks, an accepance formula $\psi$ over $\oM$, and a
function
$\rem:\delta\rightarrow Q \times \Sigma \times 2^{\oM}\times Q$
assigning new marks to transitions (i.e., for each
$t=(p,a,M',q)\in\delta$, we assume that $\rem(t)=(p,a,\oM',q)$ for
some $\oM'\subseteq\oM$) such that $|\oM|<|M|$ and the automaton
$\mB=(Q,\oM,\Sigma,q_I,\rem(\delta),\psi)$ is equivalent to $\mA$. To
ensure that the modified automaton is equivalent to the original one,
we actually look for $\psi$ and $\rem$ such that each run
$\pi=t_0t_1t_2\ldots$ of $\mA$ is accepting if and only if the run
$\rem(t_0)\rem(t_1)\rem(t_2)\ldots$ of $\mB$ is accepting.

We start with several simple observations. Acceptance of a run $\pi$
is fully determined by the set $\minf(\pi)$.
% of acceptance marks that
% appear infinitely often on $\pi$, which is in turn fully determined by
% the set $\minf(\pi)$ of transitions appearing infinitely often in
% $\pi$.
Further, each set $\minf(\pi)$ for a run $\pi$ is a cycle and vice
versa. Hence, our reduction methods is looking for a new acceptance
formula $\psi$ and function $\rem$ such that for each cycle
$T\subseteq\delta$, it holds that $T$ satisfies $\varphi$ if and only
if $\rem(T)$ satisifes $\psi$. This can be roughly denoted by the
formula
\[
  \forall T\subseteq\delta~.~\mcycle(T)\implies\big(\msat_\varphi(T) ~\iff~ \msat_{\psi,\rem}(T)\big).
\]
In fact, this corresponds to the shape of the QBF formulas we will
construct. As we are looking for $\psi$ and $\rem$ such that the
formula holds, the subformula $\msat_{\psi,\rem}(T)$ contains many
free variables representing possible instances of $\psi$ and
$\rem$. If the formula is satisfiable, then each of its models encodes
a desired instance of $\psi$ and $\rem$.  In the following, we assume
that we are looking for a new acceptance formula $\psi$ in DNF. Note
that our reduction method can be easily adapted to look for $\psi$ of
a different shape.

Now we describe the construction of QBF formulas in detail. The
construction is parametrized by two integers $C,K\ge 0$, where $K$ is
the desired number of acceptance marks and $C$ is the number of
clauses of $\psi$. For simplicity, we assume that the reduced
automaton will use the acceptance marks $N_K=\{1,2,\ldots,K\}$.
%Further, we consider only subsets $T\subseteq\bigcup_{\textrm{SCC}~S}\delta_S$
We start with a description of Boolean variables used in the
constructed QBF formulas.
\begin{itemize}
\item For each transition $t\in\delta$, variable $e_t$ says whether
  $t$ is in the current set $T$ or not.
  \[e_t=\left\{
      \begin{array}{ll}
        1 & \textrm{if }t\in T\\
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
%  In fact, we consider variables 
\item For each transition $t\in\delta$ and acceptance mark $k\in N_K$,
  variable $n_{t,k}$ says whether $k$ is on the transition
  $\rem(t)$ or not.
  \[n_{t,k}=\left\{
      \begin{array}{ll}
        1 & \textrm{if }k\in\mks(\rem(t))\\
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
\item For each $c\in\{1,2,\ldots,C\}$ and acceptance mark $k\in N_K$,
  variables $i_{c,k}$ and $f_{c,k}$ say whether the $c^\textrm{th}$
  clause of $\psi$ contains terms $\Inf k$ or $\Fin k$, respectively.
  \[i_{c,k}=\left\{
      \begin{array}{ll}
        1 & \textrm{if the $c^\textrm{th}$ clause of $\psi$ contains $\Inf k$}\\
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
  \[f_{c,k}=\left\{
      \begin{array}{ll}
        1 & \textrm{if the $c^\textrm{th}$ clause of $\psi$ contains $\Fin k$}\\
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]

\end{itemize}
By $\vec{e},\vec{n},\vec{i},\vec{f}$ we denote the vectors of all
variables of the form $e_t$, $n_{t,k}$, $i_{c,k}$, and $f_{c,k}$,
respectively. The constructed QBF formulas have the form 
\[
  \Phi_{C,K}(\vec{n},\vec{i},\vec{f})~~=~~\forall \vec{e}~.~\mcycle(\vec{e})\implies\big(\msat_\varphi(\vec{e}) \iff \msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})\big).
\]
It remains to describe the subformulas $\mcycle(\vec{e})$,
$\msat_\varphi(\vec{e})$, and
$\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$. The subformula
$\mcycle(\vec{e})$ will be defined as the last one and we present
three versions of it.

The subformula $\msat_\varphi(\vec{e})$ says whether $T$ satisfies the
original acceptance formula $\varphi$ and it is derived directly from
$\varphi$. Recall that $T$ satisfies $\Inf m$ iff $m\in\mks(T)$, which
means that $T$ contains some transition with mark $m$. As the
transitions with mark $m$ form the set $\delta_m$, $\Inf m$ can be
expressed by $\bigvee_{t\in\delta_m}e_t$. Similarly, $T$ satisfies
$\Fin m$ iff $m\not\in\mks(T)$, which can be expressed by
$\bigwedge_{t\in\delta_m}\neg e_t$. Hence, $\msat_\varphi(\vec{e})$
arises from $\varphi$ by replacing
\begin{itemize}
\item all terms of the form $\Inf m$ by $\bigvee_{t\in\delta_m}e_t$ and
\item all terms of the form $\Fin m$ by $\bigwedge_{t\in\delta_m}\neg e_t$.
\end{itemize}

Now we construct the subformula
$\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ that evaluates to true
iff $\rem(T)$ satisfies~$\psi$. The subformula reflects the basic
structure of $\psi$. As we assume that $\psi$ is a disjunction of $C$
clauses, we have
\[
  \msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})=\bigvee_{c\in\{1,2,\ldots,C\}}\xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})
\]
where each $\xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ corresponds to
one clause. Recall that the presence of terms $\Inf k$ and $\Fin k$ in
the $c^\textrm{th}$ clause is given by variables $i_{c,k}$ and
$f_{c,k}$, respecively. $\Inf k$ is satisfied by $\rem(T)$ iff $T$
contains a transition $t$ such that $k\in\mks(\rem(t))$, which can be
expressed as $\bigvee_{t\in\delta}(e_t\wedge n_{t,k})$. Similarly,
$\Fin k$ is satisfied by $\rem(T)$ iff there is no transition $t\in T$
such that $k\in\mks(\rem(t))$, which can be expressed as
$\bigwedge_{t\in\delta}\neg(e_t\wedge n_{t,k})$. Hence, we set
\[
  \xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})=
  \bigwedge_{k\in N_K}\Big(i_{c,k}\implies\bigvee_{t\in\delta}(e_t\wedge n_{t,k})\Big)\wedge\Big(f_{c,k}\implies\bigwedge_{t\in\delta}\neg(e_t\wedge n_{t,k})\Big).
\]

It remains to define the subformula $\mcycle(\vec{e})$. Let $\Te$
denote the set of transitions represented by $\vec{e}$. The original
intended meaning of $\mcycle(\vec{e})$ is
\[
  \mcycle(\vec{e}) \iff \Te\textrm{ is a cycle}.
\]
In fact, only the direction ``$\Longleftarrow$'' is needed for the
correctness of our reduction method. If there are some valuations of
$\vec{e}$ such that $\mcycle(\vec{e})$ holds and $\Te$ is not a cycle,
then we will superfluously require the equivalence
$\msat_\varphi(\vec{e}) \iff
\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ on these valuations.
% adds a superfluous constraint on $\psi$ (represented by
% $\vec{i},\vec{f}$) and $\rem$ (represented by $\vec{n}$).
These superfluous constraints can lead to loss of reduction
opportunities, but not to incorrectness. This observation allows us to
trade the precision of $\mcycle(\vec{e})$ for its simplicity.
formula.
%
We define three versions of $\mcycle(\vec{e})$:
\begin{itemize}
\item $\mcycle_1(\vec{e})$ is a lightweight version, which only says
  that $\Te$ is nonempty. It does not use the information about
  automaton structure, but it comes with an interesting simplification
  of the whole formula $\Phi_{C,K}$.
\item $\mcycle_2(\vec{e})$ is an intermediate version. It says that $\Te$
  is nonempty and every transition in $\Te$ has % to have
  a preceding
  and a succeeding transition in $\Te$, which is a necessary condition
  for being a cycle, but not a sufficient one.
\item $\mcycle_3(\vec{e})$ is a strict version saying that $\Te$ is a
  cycle. Unfortunately, it uses additional universally quantified
  variables corresponding to automata states. Transformation of
  $\Phi_{C,K}$ to prenex normal form turns the quantifiers to
  existential ones and the resulting formula thus contains quantifier
  alternation.
\end{itemize}
We write $\Phi_{j,C,K}$ %when we want
to emphasize that a particular
formula $\Phi_{C,K}$ contains the version $\mcycle_j(\vec{e})$.

\subsection{Lightweight version $\mcycle_1(\vec{e})$}
The lightweight version is defined as
\[
  \mcycle_1(\vec{e})=\bigvee_{t\in\delta}e_t
\]
which means only that $\Te$ is nonempty. This condition is satisfied by
every cycle.

The formula $\Phi_{1,C,K}$ built with $\mcycle_1(\vec{e})$ actually
says that for every nonempty set $T\subseteq\delta$, $T$ satisfies
$\varphi$ if and only if $\rem(T)$ satisfies $\psi$. Note that the
formula is not affected by the placement of transitions in the
automaton. The only aspect of a transition $t$ reflected by the
formula is its set of marks $\mks(t)$. Hence, we do not have to
distinguish between transitions with the same sets of marks.

Formally, we define an equivalence ${\sim}\subseteq\delta\times\delta$
on transitions such that $t_1\sim t_2$ whenever $\mks(t_1)=\mks(t_2)$.
\begin{lemma}
  Assume that there is a function $\rem$ and a formula $\psi$ such that 
  \[
    \textrm{for every nonempty set $T\subseteq\delta$ it holds }
      (T~\msat~\varphi~\iff~\rem(T)~\msat~\psi).\tag{$1$}\label{eq:lem1} 
  \]  
  Then there exists a function $\rem'$ that respects % the equivalence
  $\sim$ (i.e.,
  if $t_1\sim t_2$ then $\rem'(t_1)=\rem'(t_2)$) and
  \[
    \textrm{for every nonempty set $T\subseteq\delta$ it holds }
    (T~\msat~\varphi~\iff~\rem'(T)~\msat~\psi).\tag{$2$}\label{eq:lem2} 
  \]  
\end{lemma}
\begin{proof}
  Let $\rem$ be a function and $\psi$ a formula such that
  \eqref{eq:lem1} holds. To construct the function $\rem'$, we first
  select one transition from each equivalence class of $\sim$. For
  every transition $t\in\delta$, by $\overline{t}$ we denote the
  selected transition equivalent to $t$. We define the function
  $\rem'$ as $\rem'(t)=\rem(\overline{t})$. Clearly, $\rem'$ respects
  the equivalence $\sim$. It remains to show that \eqref{eq:lem2}
  holds for $\rem'$ and $\psi$.

  Let $T\subseteq\delta$ be an arbitrary nonempty set. We construct
  the set $\overline{T}=\{\overline{t}\mid t\in T\}$. As
  $\mks(t)=\mks(\overline{t})$ for all transitions, we get
  $\mks(T)=\mks(\overline{T})$ and thus
  \[
    T~\msat~\varphi~\iff~\overline{T}~\msat~\varphi.
  \]
  Now we apply $\eqref{eq:lem1}$ on $\overline{T}$ to get that
  \[
    \overline{T}~\msat~\varphi~\iff~\rem(\overline{T})~\msat~\psi.
  \]
  Finally, the definition of $\rem'$ implies that
  $\rem'(T)=\rem(\overline{T})$ and thus
  \[
    \rem(\overline{T})~\msat~\psi~\iff~\rem'(T)~\msat~\psi.
  \]
  Altogether, we obtain
  \[
    T~\msat~\varphi~\iff~\overline{T}~\msat~\varphi~\iff~\rem(\overline{T})~\msat~\psi~\iff~\rem'(T)~\msat~\psi
  \]
  which proves that \eqref{eq:lem2} holds for $\rem'$ and $\psi$. 
\end{proof}

The lemma suggests the following simplification of the whole formula
$\Phi_{1,C,K}$ built with $\mcycle_1(\vec{e})$. Before we build the
formula, we compute the equivalence $\sim$ on automata transitions and
temporarily remove all transitions except one of each equivalence class. Then we
build the formula $\Phi_{1,C,K}$ for the pruned automaton. The more
transitions we removed, the shorter formula with less $e_t$ variables
we obtain. If the formula $\Phi_{1,C,K}$ for the pruned automaton is
satisfiable, we derive $\rem$ and $\psi$ from its model and extend % use them
% with the original automaton. We only need to extend
$\rem$ to all transitions of the original automaton such that
it changes the acceptance marks on all equivalent transitions in the
same way. In the following, we use this simplification whenever
$\Phi_{1,C,K}$ is employed.


\subsection{Intermediate version $\mcycle_2(\vec{e})$}
The intermediate version says that $\Te$ is nonempty and for each state
$q\in Q$ it holds that $\Te$ contains a transition leading to $q$ if
and only if it contains a transition leading from $q$.
Formally,
\[
  \mcycle_2(\vec{e})=\bigvee_{t\in\delta}e_t~\wedge~
  \bigwedge_{q\in Q}\Big(\bigvee_{t'\in\delta~\cap~Q\times\Sigma\times 2^M\times\{q\}}\hspace{-1cm}e_{t'}\hspace{1cm}\iff
  \bigvee_{t''\in\delta~\cap~\{q\}\times\Sigma\times 2^M\times Q}\hspace{-1cm}e_{t''}\hspace{6mm}\Big).
\]
This condition is satisfied by every cycle, but also by some sets of
transitions that are not cycles. Some examples of such sets are provided in Figure~\ref{fig:inter}.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=90,xshift=-5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] (p)
      (p) edge[out=30,in=150] (q)
      (q) edge[out=30,in=-30,looseness=10] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}

    \begin{scope}[initial angle=90,densely dotted,black!20]
      \node[state,initial,solid,draw=black] (p) at (0,0) {};
      \node[state,solid,draw=black] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10,black,solid] (p)
      (p) edge[out=30,in=150,black,solid] (q)
      (q) edge[out=30,in=-30,looseness=10,black,solid] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}

    \begin{scope}[initial angle=90,densely dotted,black!20,xshift=5cm]
      \node[state,initial,solid,draw=black] (p) at (0,0) {};
      \node[state,solid,draw=black] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10,black,solid] (p)
      (p) edge[out=30,in=150] (q)
      (q) edge[out=30,in=-30,looseness=10,black,solid] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}
  \end{tikzpicture}
  \caption{An automaton structure where transition labels and
    acceptance marks are not depicted (left) and two sets $\Te$ that
    are not cycles even if $\mcycle_2(\vec{e})$ holds (middle and
    right)}
  \label{fig:inter}
\end{figure}

\subsection{Strict version $\mcycle_3(\vec{e})$}
Before we give the definition of $\mcycle_3(\vec{e})$, we prove that
cycles can be characterised in the following way.
\begin{lemma}
  A nonempty set $T\subseteq\delta$ is a cycle if and only if for each set of
  states $S\subseteq Q$ it holds that
  \begin{enumerate}[A.]
  \item\label{en:1} all transitions in $T$ lead from a state in $S$ to a state in $S$ (i.e., $T\subseteq\delta_S$) or
  \item\label{en:2} all transitions in $T$ lead from a state outside $S$ to a state outside $S$ (i.e., $T\subseteq\delta_{Q\smallsetminus S}$) or
  \item\label{en:3} $T$ contains a transition leading from a state in $S$ to a state outside $S$ and a transition leading from a state outside
    $S$ to a state in $S$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We first prove the direction ``$\Longrightarrow$''. Let $T$ be a
  cycle and $S\subseteq Q$ be an arbitrary set of states. We show that
  if (\ref{en:1}) and (\ref{en:2}) do not hold, then (\ref{en:3}) has
  to hold. Hence, assume that $T\not\subseteq\delta_S$ and
  $T\not\subseteq\delta_{Q\smallsetminus S}$. Then there are two
  cases.
  \begin{itemize}
  \item $T$ contains a transtition $t\in\delta_S$ and a transition
    $t'\in\delta_{Q\smallsetminus S}$. The definition of a cycle
    implies that there exists a path $t_1t_2\ldots t_n\in T^+$ from a
    state $p$ back to $p$ containing both $t$ and $t'$. However, this
    implies that $T$ contains a transtion leading from a state in $S$
    to a state outside $S$ and a transtion leading from a state outside $S$
    to a state in $S$.
  \item $T$ contains a transition $t$ leading from a state in $S$ to a
    state outside $S$ (or vice versa). However, as $T$ is a cycle,
    there exists a path $t_1t_2\ldots t_n\in T^+$ that leads from a
    state $p$ to the same state and contains $t$. Hence, $T$ has to
    contain also a transition leading from a state outside $S$ to a
    state in $S$ (or vice versa).
  \end{itemize}
  In both cases, (\ref{en:3}) holds.

  Now we prove the opposite direction ``$\Longleftarrow$'' by
  contraposition. Assume that a nonempty set $T$ is not a cycle. We
  show that there is a set $S\subseteq Q$ such neither (\ref{en:1})
  nor (\ref{en:2}) nor (\ref{en:3}) holds. Let $p$ be a state such
  that some transition of $T$ leads from $p$. We define the set
  \[
    \post=\{p\}\cup\{q\in Q\mid \textrm{there is a path in }T^+\textrm{ from }p\textrm{ to }q\}
  \]
  of states reachable from $p$ via transitions in $T$ and the set
  \[
    \pre=\{p\}\cup\{q\in Q\mid \textrm{there is a path in }T^+\textrm{ from }q\textrm{ to }p\}
  \]  
  of states from which $p$ is reachable via transtitions of $T$. As
  there is a transition of $T$ leading from $p$, we have that
  $T\not\subseteq\delta_{Q\smallsetminus\post}$ and
  $T\not\subseteq\delta_{Q\smallsetminus\pre}$, i.e., (\ref{en:2})
  does not holds for $\post$ and $\pre$. Further, the definition of
  $\post$ implies that there is no transition of $T$ leading from a
  state in $\post$ to a state outside $\post$, which means that
  (\ref{en:3}) does not hold for $\post$. Similarly, $T$ contains no
  transition leading from a state outside $\pre$ to a state in $\pre$,
  which means that (\ref{en:3}) does not hold for $\pre$. Now we prove
  by contradition that (\ref{en:1}) does not hold for at least one of
  $\post,\pre$. Hence, let us assume that $T\subseteq\delta_\post$ and
  $T\subseteq\delta_\pre$. Then for each $t_i\in T$ leading from $p_i$
  to $q_i$ we have that $p_i\in\post$ and $q_i\in\pre$, which implies
  that
  \begin{itemize}
  \item $p_i=p$ (we set $\rho'_i=\varepsilon$ in this case) or
    there is a path $\rho'_i\in T^+$ leading from $p$ to $p_i$, and
  \item $q_i=p$ (we set $\rho''_i=\varepsilon$ in this case) or
    there is a path $\rho''_i\in T^+$ leading from $q_i$ to $p$.
  \end{itemize}
  Then there is a path $\rho_i=\rho'_it_i\rho''_i\in T^+$ leading from
  $p$ back to $p$ and containing $t_i$. If we concatenate all these
  paths, we get the path $\rho_1\rho_2\ldots\rho_{|T|}\in T^+$ that
  contains all transitions of $T$ and leads from $p$ back to $p$,
  which means that $T$ is a cycle.  This is a contradiction.
\end{proof}

The formula $\mcycle_3(\vec{e})$ says that $\Te$ is nonempty and each
set $S\subseteq Q$ satisfies (\ref{en:1}) or (\ref{en:2}) or
(\ref{en:3}).  For each state $q\in Q$, variable $s_q$ says whether
$q$ is in the current set $S$ or not.
\[s_q=\left\{
    \begin{array}{ll}
      1 & \textrm{if }q\in S\\
      0 & \textrm{otherwise}    
    \end{array}\right.
\]
By $\vec{s}$ we denote the vectors of all variables of the form $s_q$.
The formula $\mcycle_3(\vec{e})$ is defined as follows.
\begin{align*}
  \mcycle_3(\vec{e})
  &=\bigvee_{t\in\delta}e_t~\wedge~\forall\vec{s}~.~\zeta_{\ref{en:1}}(\vec{e},\vec{s})\,\vee\,
    \zeta_{\ref{en:2}}(\vec{e},\vec{s})\,\vee\,
    \zeta_{\ref{en:3}}(\vec{e},\vec{s})\\ %\qquad\textrm{where}\\
  \zeta_{\ref{en:1}}(\vec{e},\vec{s}) &= \bigwedge_{t=(p,a,M',q)\in\delta}\hspace{-5mm}\big(e_t\implies (s_p\wedge s_q)\big)\\
  \zeta_{\ref{en:2}}(\vec{e},\vec{s}) &= \bigwedge_{t=(p,a,M',q)\in\delta}\hspace{-5mm}\big(e_t\implies (\neg s_p\wedge \neg s_q)\big)\\
  \zeta_{\ref{en:3}}(\vec{e},\vec{s}) &= \big(\bigvee_{t=(p,a,M',q)\in\delta}\hspace{-5mm}e_t\wedge s_p\wedge \neg s_q\big) ~\wedge~
  \big(\bigvee_{t=(p,a,M',q)\in\delta}\hspace{-5mm}e_t\wedge \neg s_p\wedge s_q\big)
\end{align*}

\subsection{SCC-based optimization}

Now we present an optimized formula construction based on the fact
that every cycle is completely included in the transition set
$\delta_S$ of some SCC $S$. Note that we cannot reduce the number of
acceptance marks in each SCC separately as all SCCs have to share the
same acceptance formula after the reduction. However, for each SCC we
can build the formula $\Phi_{C,K}$ separately and then we can put all
these formulas into one conjunction such that they share the variables
$\vec{i},\vec{f}$.

Now we describe the construction of optimized QBF formulas
$\Phi^\mathit{opt}_{j,C,K}$ formally. Given an automaton
$\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$ and its SCC $S$, by $\mA^S$ we
denote the automaton corresponding to the part of $\mA$ delimited by
$S$, i.e., $\mA^S=(S,M,\Sigma,q',\delta_S,\varphi)$ where $q'$ is an
arbitrary state of $S$. Further, let $\vec{n}_S$ denote the vector of
variables $n_{t,k}$ where $t\in\delta_S$ and $k\in N_K$. By
$\Phi^S_{j,C,K}(\vec{n}_S,\vec{i},\vec{f})$ we denote the formula
$\Phi_{j,C,K}$ constructed for $\mA^S$ as presented above.
Finally, we define the optimized QBF formula as
\[
  \Phi^\mathit{opt}_{j,C,K}(\vec{n}',\vec{i},\vec{f})=\bigwedge_{\textrm{SCC }S}\Phi^S_{j,C,K}(\vec{n}_S,\vec{i},\vec{f})
\]
where $\vec{n}'$ is the vector of all varibles contained in vectors
$\vec{n}_S$ for SCCs $S$.

One effect of this optimization is that the formula
$\Phi^\mathit{opt}_{j,C,K}$ contains no variables $n_{t,k}$ %and $e_t$
for transitions $t$ that do not lead between states of the same SCC.
The acceptance marks on such a transition $t$ do not affect the
acceptance of any run as $t$ appears at most once on each run. For
these transitions $t$, we can define $\rem(t)$ such that
$\mks(\rem(t))=\emptyset$.

%}}}
%{{{ algorithm

\section{Reduction algorithm}\label{sec:algo}

This section explains how we use the QBF formulas constructed in the
previous section to reduce the number of acceptance marks in TELA
automata. First, we describe a \emph{single-level} reduction, which
uses only a single kind of QBF formulas. More precisely, we talk about
\emph{level~1}, \emph{level~2}, or \emph{level~3} reduction when
$\Phi^\mathit{opt}_{1,C,K}$, $\Phi^\mathit{opt}_{2,C,K}$, or
$\Phi^\mathit{opt}_{3,C,K}$ is used, respectively.

% \begin{algorithm}[t]
%   \DontPrintSemicolon
%   \SetKwFunction{FextendBackward}{extendBackward}
%   \SetKwProg{PI}{Procedure}{}{}
%   \PI{$\mathit{SingleLevelReduction}(\mA,j,\mathit{reduceC})$}{
%     \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$, level $j\in\{1,2,3\}$, $\mathit{reduceC}\in\{\true,\false\}$}
%     \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
%     \;
%   %   \If{$L(\mA)=\emptyset$}{
%   % %      \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'=\{(p,a,\emptyset,q)\mid(p,a,M',q)\in\delta\}$
%   %       \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all acceptance marks removed
%   %     }
%     $C_\mA\gets$ the number of clauses in the acceptance formula of $\mA$ transformed to DNF\;
%     $K_\mA\gets$ the number of acceptance marks in $\mA$\;
%     $C\gets C_\mA$\;
%     $K\gets K_\mA$\;
%     $\mathit{stop}\gets\false$\;
%     \While(\tcp*[f]{reduction of the number of marks}){$\neg\mathit{stop}~\wedge~K>0$}{
%       $\Phi\gets\Phi^\mathit{opt}_{j,C,K{-}1}$ for $\mA$\;
%       \leIf{$\mathit{satisfiable}(\Phi)$}{$K\gets K{-}1$}{$\mathit{stop}\gets\true$}
%     }
%     \If(\tcp*[f]{check whether the condition $\false$ fits}){$K=1~\wedge~\mathit{stop}$}{
%       $\Phi\gets\Phi^\mathit{opt}_{j,0,0}$ for $\mA$\; 
%       \If{$\mathit{satisfiable}(\Phi)$}{
%         \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all marks removed
%       }
%     }  
%     \If(\tcp*[f]{reduction of the number of clauses}){$\mathit{reduceC}$}{
%       $\mathit{stop}\gets\false$\;
%       \While{$\neg\mathit{stop}~\wedge~C>1$}{
%         $\Phi\gets\Phi^\mathit{opt}_{j,C-1,K}$ for $\mA$\;
%         \leIf{$\mathit{satisfiable}(\Phi)$}{$C\gets C{-}1$}{$\mathit{stop}\gets\true$}
%       }
%     }
%     \eIf{$K=K_\mA~\wedge~C=C_\mA$}{
%       \KwRet $\mA$
%     }{
%       compute $\rem$ and $\psi$ from a model of $\Phi^\mathit{opt}_{j,C,K}$\;
%       \KwRet $(Q,N_K,\Sigma,q_I,\rem(\delta),\psi)$
%     }
%   }\;
%   \caption{The single-level reduction procedure}
%   \label{alg:single}
% \end{algorithm}

\begin{algorithm}[t]
  \DontPrintSemicolon
  \SetKwFunction{FextendBackward}{extendBackward}
  \SetKwProg{PI}{Procedure}{}{}
  \PI{$\mathit{SingleLevelReduction}(\mA,j,\mathit{reduceC})$}{
    \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$, level $j\in\{1,2,3\}$, $\mathit{reduceC}\in\{\true,\false\}$}
    \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
    \;
  %   \If{$L(\mA)=\emptyset$}{
  % %      \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'=\{(p,a,\emptyset,q)\mid(p,a,M',q)\in\delta\}$
  %       \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all acceptance marks removed
  %     }
    $C_\mA\gets$ the number of clauses in the acceptance formula of $\mA$ transformed to DNF\;
    $K_\mA\gets$ the number of acceptance marks in $\mA$\;
    $C\gets C_\mA$\;
    $K\gets K_\mA$\;
%    \While(\tcp*[f]{reduction of the number of marks}){$K>1~\wedge~\mathit{satisfiable}(\Phi^\mathit{opt}_{j,C,K{-}1})$}{$K\gets K{-}1$}
    \lWhile{$K>1~\wedge~\mathit{satisfiable}(\Phi^\mathit{opt}_{j,C,K{-}1})$}{$K\gets K{-}1$}
    \If{$K=1$}{
      \If(\tcp*[f]{check the condition $\true$}){all cycles in $\mA$ are accepting}{ %$\mathit{satisfiable}(\Phi^\mathit{opt}_{j,1,0})$}{
        \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\true)$ where $\delta'$ is $\delta$ with all marks removed
      }
      \If(\tcp*[f]{check the condition $\false$}){all cycles in $\mA$ are rejecting}{ %$\mathit{satisfiable}(\Phi^\mathit{opt}_{j,0,0})$}{
        \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all marks removed
      }
    }  
    \If(\tcp*[f]{reduction of the number of clauses}){$\mathit{reduceC}$}{
      \lWhile{$C>1~\wedge~\mathit{satisfiable}(\Phi^\mathit{opt}_{j,C-1,K})$}{$C\gets C{-}1$}
    }
    \If{$K<K_\mA~\vee~C<C_\mA$}{
      compute $\rem$ and $\psi$ from a model of $\Phi^\mathit{opt}_{j,C,K}$\;
      \KwRet $(Q,N_K,\Sigma,q_I,\rem(\delta),\psi)$
    }
    \KwRet $\mA$
  }\;
  \caption{The single-level reduction procedure}
  \label{alg:single}
\end{algorithm}

The reduction procedure called $\mathit{SingleLevelReduction}$ is
given in Algorithm~\ref{alg:single}. Besides the reduction of
acceptance marks, the algorithm also reduces the number of clauses in the acceptance formula if the last argument $\mathit{reduceC}$ is set to
$\true$.
% In the first step, the procedure checks whether the input
% automaton represents the empty language and if this is the case, it
% returns the same automaton with acceptance conditon $\false$ and with
% all acceptance marks removed. Otherwise it
The first \textbf{while} loop gradually decreases the number of marks
until $K=1$ is reached or the QBF solver behind the function
$\mathit{satisfiable}(\Phi^\mathit{opt}_{j,C,K{-}1})$ fails to reduce
the number of marks, i.e., it claims unsatisfiability of the formula
or it runs out of resources. If the loop ends with $K=1$, we check
whether an acceptance condition without any mark (i.e., $\true$ or
$\false$) can be used. These checks are based on an inspection of the
automaton rather than on QBF solving. If some of the checks succeeds,
we return the corresponding automaton without any acceptance
mark. Otherwise, if $\mathit{reduceC}$ is set to $\true$ then the
procedure gradually reduces the number of clauses in the second
\textbf{while} loop. Note that the loop never checks for acceptance
condition with 0 clauses as it is equivalent to $\false$ and this case
was treated above. Finally, if the procedure succeeds to reduce the
number of marks or clauses, it constructs the modified
automaton. Otherwise, it returns the original automaton.

The algorithm can be reformulated to use an incremental approach
instead of building a new formula in each iteration of the
\textbf{while} loops. The incremental version of the first
\textbf{while} loop builds the formula
$\Phi=\Phi^\mathit{opt}_{j,C,K{-}1}$ only in the first iteration. In
each subsequent iteration, it extends this formula with a condition
saying that one more mark is not used in the automaton, i.e., the mark
is neither on edges, nor in the acceptance formula. For example, if we
want to say that the mark $k\in N_K$ is not used, we replace $\Phi$ by
\[
  \Phi~\wedge~\bigwedge_{t\in\delta}\neg n_{t,k}~\wedge\bigwedge_{c\in\{1,2,\ldots C\}}(\neg i_{c,k}\wedge\neg f_{c,k}).
\]
The second \textbf{while} can be transformed to an incremental version
similarly. The incremental approach benefits from the fact that some
QBF solvers can decide an extended formula faster as they reuse the
information computed when solving the original formula.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=90,xshift=-3.5cm]
      \node (l) at (1,1.3) {automaton $\mA$};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={1}{1}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic[pos=.33] {acc={2}{2}} pic[pos=.67] {acc={3}{3}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={3}{3}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$(\Fin\tacc{1}{1}\wedge\Inf\tacc{2}{2})\vee(\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}\wedge\Inf\tacc{3}{3})$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=3.5cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,1,\true)$}; %{level 1:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={2}{2}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic[pos=.33] {acc={0}{0}} pic[pos=.67] {acc={2}{2}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={1}{1}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}\wedge\Inf\tacc{2}{2}$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=-3.5cm,yshift=-4.1cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,2,\true)$}; %{level 2:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic {acc={0}{0}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={1}{1}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=3.5cm,yshift=-4.1cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,3,\true)$}; %{level 3:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Fin\tacc{0}{0}$};
    \end{scope}
  \end{tikzpicture}
  \smallskip
  
  \caption{An example illustrating the results of the three
    single-level reductions: an input automaton $\mA$ and the automata
    obtained by reducing it with level 1, level 2, and level 3.}
  \label{fig:example}
\end{figure}

Figure~\ref{fig:example} shows a very simple automaton $\mA$ and the
three automata produced by calls of
$\mathit{SingleLevelReduction}(\mA,j,\true)$ for $j\in\{1,2,3\}$. The
figure clearly illustrates that the higher level of reduction we use,
the more acceptance marks can be reduced. On the other side, lower
levels are typically faster. The best results can be often achieved by
combining reductions of all levels. We call this approach
\emph{multi-level} reduction. It is a straightforward sequential
application of the three levels, see Algorithm~\ref{alg:multi}.

\begin{algorithm}[t]
  \DontPrintSemicolon
  \SetKwFunction{FextendBackward}{extendBackward}
  \SetKwProg{PI}{Procedure}{}{}
  \PI{$\mathit{MultiLevelReduction}(\mA,\mathit{reduceC})$}{
    \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$ and $\mathit{reduceC}\in\{\true,\false\}$}
    \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
    \;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,1,\false)$\;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,2,\false)$\;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,3,\mathit{reduceC})$\;
    \KwRet $\mA$
  }\;
  \caption{The multi-level reduction procedure}
  \label{alg:multi}
\end{algorithm}

%}}}
%{{{ implementation

\section{Implementation}\label{sec:implementation}

The presented reduction algorithms have been implemented in a tool
called \telatko. The tool is implemented in Python 3 and uses the Spot
library~\cite{duret.16.atva2} for automata parsing and manipulation
and the theorem prover Z3~\cite{demoura.08.tacas} to solve the
satisfiability of QBF formulas. \telatko is available at
\url{https://gitlab.fi.muni.cz/xschwar3/telatko} under the GNU GPLv3
license. The tool can be executed by the command 
\begin{center}
  \texttt{telatko -F <input.hoa> [-L }$j$\texttt{] [-C] [-I] [-T }$t$\texttt{] [-O <output.hoa>]}
\end{center}
where
\begin{description}
\item[\texttt{-F <input.hoa>}] specifies the file with the input automaton in HOA format~\cite{babiak.15.cav}, 
\item[\texttt{-L }$j$] specifies the reduction level; if omitted, the multi-level reduction is used,
\item[\texttt{-C}] switches on the reduction of the number of clauses
  after the number of marks is reduced (it corresponds to
  $\mathit{reduceC}=\true$ in Algortihms~\ref{alg:single}
  and~\ref{alg:multi}),
\item[\texttt{-I}] switches on the incremental version,
\item[\texttt{-T }$t$] sets the timeout for QBF query to $t$ seconds (the default value is 50 seconds), 
\item[\texttt{-O <output.hoa>}] specifies the output file; if omitted,
  the produced automaton is sent to \textit{stdout} in the HOA format.
\end{description}

If some call of the function
$\mathit{satisfiable}(\Phi^\mathit{opt}_{j,C,K{-}1})$ in the first
\textbf{while} loop of Algorithm~\ref{alg:single} does not return
$\true$, then the name of the output automaton encodes the reason for
it. In the case of a single level reduction, the name has the form
\texttt{L$j$\_$k$\_$X$}, where $j$ is the considered level, $k=K-1$ is
the number of acceptance marks considered by the formula, $X$ is either
\texttt{U} if the formula is unsatisfiable or \texttt{T} if the solver
did not decided within the time limit. If $X$ is \texttt{T}, we longer
timeout may lead to further reductions. a If the multi-level reduction
is used, the automaton name contains the information from all
levels. For example, the name `\texttt{L1\_5\_U L2\_3\_U L3\_1\_T}'
means that level 1 reduced the number of marks to 6 (reduction to 5 is
impossible on this level), level 2 reduced it to 4, and level 3 to 2
as the QBF solver did not finished in the time limit when trying to
reduce the number of marks to
1.%when tryint the automaton may be potentially reduced further.


% that does not . 
% The parameters of the last query of the QBF solver are encoded in the name of the automaton.

% The name of the automaton is in the following format:
% \begin{center}
%   \texttt{level\_marks\_solver}
% \end{center}
% where 
% \begin{itemize}
%     \item \texttt{level} $\in \{L1, L2, L3, T, F\}$ and it gives us the information about which level of simplification was applied (or in case of $T$ and $F$ if the acceptance formula can be $\true$ or $\false$).
%     \item \texttt{marks} $\in \mathbf{N}$ representing the number of marks we built the formula for.
%     \item \texttt{solver} $\in \{U, T, S\}$ where $U$ means that the query was unsatisfiable, $T$ means the solver timeouted and $S$ means that the simplification is satisfiable.
% \end{itemize}

% Note that we are only interested in the result of the last query, therefore we get the information that the simplification was satisfiable only if the result automaton has zero acceptance marks. Meaning that the acceptance condition is either $\true$ or $\false$.



%}}}
%{{{ experimental evaluation 

\section{Experimental evaluation}\label{sec:experiments}

We have used the tool \texttt{genltl} of the Spot
library~\cite{duret.16.atva2} to generate LTL formulas from
literature. The parametrized formulas were generated for all
combinations of parameter values from 1 to 4. We used the tool
\texttt{ltlfilt} of the Spot library to simplify the formulas and
remove duplicates. Altogether, we have generated 348 unique LTL
formulas. These have been translated to deterministic TELA by two
state-of-the-art translators from the Owl
library~\cite{kretinsky.18.atva} and to nondeterministic TELA by
another two state-of-the-art translators, namely \texttt{ltl2tgba}
from the Spot library~\cite{duret.16.atva2} and
\texttt{ltl3tela}~\cite{major.19.atva}. Each of the four automata sets
produced by individual tools contains less than 348 automata as not all
of the formulas are successfully translated due to a timeout of 60
seconds. Further, we have removed automata with 0 or 1 acceptance
marks as there is a little point reducing these. Table
\ref{tab:ltltranslators} shows the exact versions and homepages of
used translators, and the number of automata produced by each
translator after removing the automata with less than two marks.

\begin{table}[b]
\caption{LTL to automata translators used for the experimental evaluation
and the number of successfully translated formulas.}
\label{tab:ltltranslators}
\centering
\begin{tabular}{lr@{~~~}lr}
\toprule
tool        & version&homepage & automata \\
\midrule
\texttt{ltl2dela} & 21.0 & \multirow{2}{*}{\url{https://owl.model.in.tum.de/}} & 129\\
\texttt{ltl2dgra} & 21.0 & & 234\\
\texttt{ltl2tgba} & 2.10.4 & \url{https://spot.lrde.epita.fr} & 70\\
\texttt{ltl3tela} & 2.2.0  & \url{https://github.com/jurajmajor/ltl3tela} & 91\\
\bottomrule
\end{tabular}
\end{table}

For each automata set (that is, the automata produced by an individual
LTL translator), we have applied all single-level reductions and the
multi-level reduction, always with incremental approach and without
reduction of the number of clauses. The timeout for each QBF query was
set to 30 seconds.

For the experiments we used the version of \texttt{telatko} build with
Spot library version 2.10.4 and Z3 version 4.8.15. The experiments
have been run on a computer with Intel® Core™ i7-8700 processor and 32
GB of memory running Ubuntu 20.04.4. We used the tool
\texttt{autcross} of the Spot library to get the statistics of the
reduced automata and the running times.

Table~\ref{tab:cumm-data} shows the cummulative numbers of marks in
the input automata sets and after each reduction, together with the
reduction ratio and total time spent by the considered reduction. The
column \textit{solver timeout} shows the number of automata for which
the last query to QBF solver did not finished within the 30 seconds
limit. The timeout of the last QBF query implies that the automaton
may be potentially further reduced by the reduction with a longer time
limit.

\begin{table}[t]
\caption{The cummulative numbers of acceptance marks before and after reduction
for various reductions and automata sets.
%\textit{X/Y solved aut.} means that out of
%\textit{Y} successfully translated LTL formulas, every run of \telatko ended
%within 120 seconds time limit on \textit{X} automata. We sum up the acceptance
%marks only on these automata.
The column \textit{solver timeout} indicates the number of instances
when the last call to the QBF solver timed out.  }
\label{tab:cumm-data}
\centering
\setlength{\tabcolsep}{10pt}
\input{table-data.tex}
\end{table}

Table~\ref{tab:heatmap} shows the number of automata coming from all
four sets that have a given number of original acceptance marks and a
given number of acceptance marks after multi-level reduction. The
table indicates that in many cases only 1 or 2 marks can be
saved. However, the achieved reduction is substantial for some
automata with a higher number of original acceptance marks. For
example, in 24 cases, we have successfully reduced 7 or more
acceptance marks to only 4.
% Moreover, there were many timeouts of the last QBF query for manof these automata.
% Let us note that some that some reductions are the results are promising, e.g. in 17 cases, we have successfully
% reduced 8 or more acceptance marks to only 4.

\begin{table}[t]
\caption{The effect of reduction.
A cell on coordinates $(x,y)$ contains the number of automata that have been
reduced from $x$ to $y$ acceptance marks. If the cell contains a sum of two
numbers, the latter represents number of automata where the last query to QBF
solver has not been answered in the time limit.}
\label{tab:heatmap}
\setlength{\tabcolsep}{4pt}
\centering
\input{table-heatmap.tex}
\end{table}

Figure~\ref{fig:quantile} presents the time spent by multi-level
reduction of automata in individual automata sets. The chart shows a
pleasing finding that for every set, most automata are reduced in
under a second and the high cumulative running times are caused by
a few complicated automata.

\begin{figure}[b!]
\caption{Performance of \telatko on different automata sets. The $x$ axis
represents the number of reduced automata, the $y$ axis shows the time spent
reducing (in seconds).}
\label{fig:quantile}
\centering
\input{quantile.tex}
\end{figure}

% Pridat do experimentu nejaky graf, ktery ukaze, jak rychle se nektere
% automaty redukovaly na minimum? Nebo spis ukazat vliv timeoutu na
% redukce?  (zvysovat timeout od 1s do 50s a vzdy ukazat miru
% redukce). Ty redukce ukazovat nejak jinak nez jen celkovym cislem
% (boxplot? Scatterplot?).

% Zkusit upravit redukci tak, aby vysledkem bylo TGBA a zkusit dale
% redukovat akceptacni znacky TGBA automatu redukovanych Spotem?

% Chceme ukazovat, ze redukce znacek muze nekdy umoznit dalsi redukci stavu?

%}}}
%{{{ conclusion

\section{Conclusions}\label{sec:conclusion}

We have presented an application of QBF solving to reduction of the number of
acceptance marks in transition-based Emerson-Lei automata. The method
has been implemented and our experimental results show that it is possible
to use the QBF solvers to find equivalent acceptance conditions of TELA
with fewer acceptance marks and without changes to automata structure.

The reduction of acceptance marks is not the only application of the
presented approach: one could possibly look for, e.g., equivalent
parity automata or automata without $\Fin$-marks, depending on the
subsequent use of the automata. Even though the QBF queries can be
time-consuming, in practice it can be well used and one can find a
good trade-off between speed and efficiency by choosing the precision of
the reduction and setting a reasonable timeout.

In the future work, it could be examined how the reductions of the acceptance
condition can contribute to further reduction of the state space by enabling
various optimizations, e.g., simulations.

%}}}

% \section{TODO}

% \noindent
% Do budoucna:
% \begin{itemize}
% \item level 1 bez SCC optimalizace
% \item nahradit weak SCC jednou hranou pro neakceptujici a jinou pro akceptujici
% \item sladit konstrukci QBF formuli s implementaci
% \item podivat se znovu na uzitecnost a potrebnost optimalizaci typu ``klauzule neni false'' a ``alespon jedna klauzule je neprazdna''
% \item sladit popis algoritmu s implementaci
% \item v experimentech nejak sledovat vztah usetreneho casu a usetrenych znacek?
% \item zkusit aplikovat na jine typy automatu (treba TGBA nebo Rabin)?
% \item zkusit, zda/jak redukce znacek umozni redukovat stavovy prostor
% \end{itemize}


%\bibliographystyle{plain}
\bibliography{mc}


\end{document}

%{{{ standard reductions

\section{Reduction based on acceptance marks relations}\label{sec:standard}

This section presents a reduction technique based on relations between
acceptance sets restricted to individual SCCs. It employs the fact
that acceptance of a run always depends only on a single SCC, namely
the SCC that contains the whole run except some finite prefix.

Let $\mA$ be a TELA with the acceptance condition $\varphi$. We assume
that $\varphi$ is in DNF. This technique has two steps.
\begin{enumerate}
\item For each SCC $S$, we make a copy $\varphi_S$ of $\varphi$ and
  simplify it according to relations between acceptance sets
  restricted to $\delta_S$. 
\item We collect the simplified acceptance conditions
  $\varphi_{S_1},\ldots,\varphi_{S_k}$ of all SCCs and merge them into
  one acceptance condition $\varphi'$. Additionally, we sometimes add
  acceptance marks to all transitions of some SCCs to make the
  resulting automaton with acceptance formula $\varphi'$ equivalent to
  the original automaton.
\end{enumerate}

% Let $\mathcal{A}$ be an original automaton and let $\psi$ be an
% acceptance condition of $\mathcal{A}$. Every run of $\mathcal{A}$ has
% an infinite suffix that takes place within one SCC $S_{i}$. Thus the
% evaluation of $\psi$ depends purely on the SCC $S_{i}$ and we can
% optimize the acceptance condition for each SCC separately. This
% optimization consists of removing redundant terms from acceptance
% condition and relabeling of acceptance marks on the transitions. The
% state and transition structure of the SCC does not change. This way we
% obtain set of simplified acceptance conditions that we merge into new
% acceptance formula $\psi'$. The automaton with relabeled transitons
% and new acceptance condition $\psi'$ we denote $\mathcal{A}'$.
% Finally, we ensure that automaton $\mathcal{A'}$ is equivalent to the
% original automaton $\mathcal{A}$.

\subsection{Simplification of $\varphi_S$ for an SCC $S$}\label{ssec:step1}
Recall that $\varphi_S$ is in DNF. Hence, we can represent it as a set
$\varphi_S=\{D_1,\ldots,D_k\}$ of disjunctive clauses.





Since formula $\psi_{i}$ is in DNF, we can represent it as a set of disjuncts $\overline{\psi_{i}} = \{D_1, D_2, \ldots D_k\}$.

Let $D_{k} \in \overline{\psi_{i}}$ be a disjunct of formula $\overline{\psi_{i}}$ and $C_{j} \in D_{k}$ a conjunct of disjunct $D_{k}$. Furthermore let  $\tacc{0}{i}, \tacc{4}{j}, \tacc{8}{k}, \tacc{2}{l} \in M$ be distinct acceptance marks that occur in $\mathcal{A}$.

In the next section, some properties of an automaton allow us to substitute a Boolean value $\true$ or $\false$ for a particular term of the formula $\psi_i$.
The consequences of this substitution are divided into a number of cases. We represent it on the set-format of formula we just defined.

\begin{itemize}
    \item If $C_{j}$ is substituted by $\true$, the conjunct is omitted from $D_{k}$. Thus $D_{k} = D_{k} \setminus \{C_{j}\}$.
    \item If $C_{j}$ is substituted by $\false$, the conjunct causes that the whole $D_{k}$ evaluates to $\false$. Thus $\overline{\psi_{i}} = \overline{\psi_{i}} \setminus \{D_{k}\}$.

\end{itemize}

That being said, we can define the reduction techniques. 

\subsubsection{Acceptance formula modifications\\} 
\label{subsection:acc_modif}
Since we optimize for each SCC separately, the acceptance formula corresponding to SCC $S_{i}$ can contain terms with acceptance marks that are not present on the transitions of $S_{i}$.
Let $\tacc{8}{k} \in M$ be an acceptance mark that is not present on any edge of $S_{i}$. Then any term that contains this acceptance mark in $\overline{\psi_{i}}$ can be immediately substituted with a boolean value and thus removed from $\overline{\psi_{i}}$.
\medskip

Therefore acceptance mark $\tacc{8}{k}$ is not visited in any run of $S_{i}$ and thus every term in form $\Fin\tacc{8}{k}$ is substituted with $\true$ and every term $\Inf\tacc{8}{k}$ is substituted with $\false$.

On the contrary, let $\tacc{4}{j}$ be an acceptance mark that is present on every transition of $S_{i}$. That means that at least one transition with $\tacc{4}{j}$ is visited infinitely often by a run of $\mathcal{S_{i}}$. Thus every term $\Fin\tacc{4}{j}$ is substituted by $\false$ and every term in form $\Inf\tacc{4}{j}$ is substituted by $\true$. 

\subsubsection{$\Inf$ conjuncts\\}
\label{subsection:simpl_inf}
Reduction of a conjunct of $\Inf\tacc{8}{k}$ form  is based on the inclusion of the sets of edges labeled with $\tacc{8}{k}$ and set of edges labeled with $\tacc{4}{j}$. If all transitions that contain an acceptance mark $\tacc{8}{k}$ also contain $\tacc{4}{j}$, we can remove $\Inf\tacc{4}{j}$ from all disjuncts, where it occurs together with $\Inf\tacc{8}{k}$. 
More formally, if the following conditions hold:
\begin{itemize}
    \item $Z(\tacc{8}{k}) \subseteq Z(\tacc{4}{j})$
    \item $\Inf\tacc{8}{k}, \Inf\tacc{4}{j} \in D_{k}$
\end{itemize}
then we can we can substitute $\Inf\tacc{4}{j}$ with Boolean value $\true$. 
This modification does not change the language because it does not affect accepting runs of $S_{i}$. The transitions can create an accepting run that has the potential to satisfy $D_{k}$ only if they are labeled with both  $\tacc{8}{k}$  and $\tacc{4}{j}$. Since $Z(\tacc{8}{k}) \subseteq Z(\tacc{4}{j})$, one can notice that that if a run satisfies $\Inf\tacc{8}{k}$ then  $\Inf\tacc{4}{j}$ is satisfied as well. Therefore if we remove $\Inf \tacc{4}{j}$ from $\overline{\psi_{i}}$, this modification does not affect the language.

\subsubsection{$\Fin$ conjuncts\\}
Similarly as in previous section, this reduction is based on inclusion.
If following conditions hold:
\begin{itemize}
    \item $Z(\tacc{8}{k}) \subseteq Z(\tacc{4}{j})$
    \item $\Fin\tacc{8}{k}, \Fin\tacc{4}{j} \in D_{k}$
\end{itemize}
then we can we can substitute $\Fin\tacc{8}{k}$ with boolean value $\true$. This modification does not change the language because from if $\tacc{4}{j}$ is visited finitely often, then also $\tacc{8}{k}$ is visited finitely often. 
\medskip

We can merge two conjuncts into one if the conjuncts always occur in the same disjuncts in $\Fin$ form. We can do so regardless of the position of the acceptance marks that are contained in the conjuncts. 
If the following condition is met:
\begin{itemize}
    \item $\forall D_{k}: \Fin\tacc{8}{k} \in D_{k} \Longleftrightarrow \Fin\tacc{4}{j} \in D_{k}$
\end{itemize}
We introduce a fresh acceptance mark $\tacc{2}{l}$, such that $Z(\tacc{2}{l}) = Z(\tacc{8}{k}) \cup Z(\tacc{4}{j})$.
 Finally, we can update $D_{k}$:
\begin{align*}
    D_{k} = (D_{k} \setminus \{ \Fin\tacc{8}{k}, \Fin\tacc{4}{j} \}) \cup \{\Fin\tacc{2}{l}\}
\end{align*}

This update basically means that $\Fin\tacc{8}{k}, \Fin\tacc{4}{j}$ are substituted by $\true$ and new conjunct $\Fin\tacc{2}{l}$ is added to $D_{k}$. The acceptance mark $\tacc{2}{j}$ is placed on every edge of the SCC $S_{i}$ that is labeled with $\tacc{8}{k}$ or $\tacc{4}{j}$.
This modification does not change the language because it does not change the acceptance runs of $S_{i}$. It only relabels the acceptance marks on edges that can be seen finitely often. 



\subsubsection{$\Fin \land \Inf$ conjuncts\\}
There are two cases when we can reduce one of the pair of $\Inf\tacc{0}{i}$ and $\Fin\tacc{2}{l}$ conjuncts.

At first, if every transition labeled with  $\tacc{0}{i}$ is also labeled with $\tacc{2}{l}$, the conjunction of $\Inf\tacc{0}{i} \land \Fin\tacc{2}{l}$ is never $\true$ because every run that visits $\tacc{2}{l}$ also visits $\tacc{0}{i}$. Therefore we can reduce the whole disjunct $D_{k}$.
If the following conditions are met:
\begin{itemize}
    \item $Z(\tacc{0}{i}) \subseteq Z(\tacc{2}{l})$
    \item $\Inf\tacc{0}{i}, \Fin\tacc{2}{l} \in D_{k}$
\end{itemize}
We substitute the whole disjunct $D_{k}$ for $\false$. In other words $\overline{\psi_{i}} = \overline{\psi_{i}} \setminus \{D_{K}\}$.

Finally we can simplify $\overline{\psi_{i}}$, if the edges labeled with $\tacc{0}{i}$ and edges labeled with $\tacc{2}{l}$ are complementary.
More formally if:
\begin{itemize}
    \item  $\Inf\tacc{0}{i}$ and $\Fin\tacc{2}{l} \in D_{k}$
    \item $Z(\tacc{0}{i}) \cap Z(\tacc{2}{l}) = \emptyset \land Z(\tacc{0}{i}) \cup Z(\tacc{2}{l}) = \delta_{S_{i}} $
\end{itemize}
Then we can substitute $\true$ for $\Inf\tacc{0}{i}$.
This reduction does not change the language because if during a run of $S_{i}$ all transitions labeled with $\tacc{2}{l}$ are visited only finitely often, then necessarily at least one transition labeled with $\tacc{0}{i}$ is visited infinitely often. Therefore removing $\Inf\tacc{0}{i}$ from $\overline{\psi_{i}}$ does not affect the language, since the validity of $\Fin\tacc{2}{l}$ implies the validity of $\Inf\tacc{0}{i}$.

\subsection{Merge of $\psi_{i}$}
After applying reduction techniques from the previous section, each $S_{i}$ has its own acceptance condition $\psi_{i}$. The goal of this section is to merge these acceptance conditions into one formula $\psi'$ with emphasis on obtaining a formula with the minimal number of acceptance sets.

At first, the algorithm finds $\psi_{i}$ with the greatest number of disjuncts and states it as a base of the new acceptance condition $\psi'$. Now the algorithm continues by the successive merging of $\psi'$ with the unmerged formula $\psi_{i}$ that has the greatest number of disjuncts. This repeats until all formulae $\psi_{i}$ are merged. This process updates the form of $\psi'$ until it reaches its final form. The process of merging two formulae consists of two phases. In the first phase a suitable pairing of disjuncts is found and in the second phase, these disjuncts are merged.

\begin{enumerate}
	\item Let $\psi'$ denote the future acceptance condition of $\mathcal{A}'$ and $\psi_{i}$ is the acceptance condition of $S_{i}$ chosen to be merged. Then the algorithm uses \emph{linear sum assignment} to determine which disjunct of $\psi_{i}$ is merged with which disjunct of $\psi'$. The process of using \emph{linear sum assignment} and the pairing procedure is described in detail in work by T. Šťastná \cite{stastna.19.bc}.
    \item Let $D_{K} \in \overline{\psi_{i}}$ be a disjunct paired with $D_{L} \in \overline{\psi'}$. All conjuncts of $D_{L}$ are initially labeled as unused. Now the algorithm maps every conjunct $C_{k} \in D_{K}$ to a suitable conjunct $C_{l} \in D_{L}$ and labels $C_{l}$ as used. \footnote{The indexes differ to emphasize the fact that they are not equal.} A conjunct $C_{l}$ is suitable for $C_{k}$ is it is on the same type ($\Fin$ or $\Inf$), it is labeled as unused. If no suitable $C_{l}$ is found, the algorithm adds $C_{k}$ to disjunct $D_{L}$ and marks it as used.
\end{enumerate}


In an acceptance mark $m_{l} \in M$ occurs in $\psi'$ in more than one conjunct, we need to check whether all of these conjuncts are mapped to conjuncts form $\psi_{i}$ with the same acceptance mark $m_{k} \in M$. If not, we resolve this conflict by replacing all additional occurrences of $m_{l}$ with fresh acceptance mark $m_{n}$ and we place $m_{n}$ on the exact transition of $\mathcal{A}'$ where $m_{l}$ is placed.
Finally, in the end, the algorithm removes every acceptance mark that is not present in $\psi'$ from the edge of $\mathcal{A}$.

\medskip

\begin{example}
Consider $\overline{\psi'} =  \{ \{ \Fin\tacc{0}{0}, \Inf\tacc{1}{1} \} , \{\Fin\tacc{0}{0} \} \}$ \\ and $\overline{\psi_{i}} = \{  \{\Fin\tacc{4}{4} \}, \{ \Fin\tacc{2}{2}, \Inf\tacc{3}{3} \} \} $. We obtain the pairing $(1,2), (2,1)$, meaning that the first disjunct of $\overline{\psi_{i}}$ is merged wit the second disjunct of $\overline{\psi'}$ and second disjunct of $\overline{\psi_{i}}$ is merged with the first disjunct of $\overline{\psi'}$. Then $\Fin\tacc{0}{0}$ is mapped to $\Fin\tacc{2}{2}$, $\Inf\tacc{1}{1} $ is mapped to $\Inf\tacc{3}{3}$ and $\Fin\tacc{0}{0}$ is again mapped to $\Fin\tacc{4}{4}$ which causes a conflict. Therefore we need to replace the second occurrence of $\tacc{0}{0}$ with fresh mark $\tacc{5}{5}$. The set-representation of formula $\psi'$ after merging is $\psi' =  \{ \{ \Fin\tacc{0}{0}, \Inf\tacc{1}{1} \} , \{\Fin\tacc{5}{5} \} \}$.

\end{example}

Unfortunately, sometimes when the optimal mapping was not found, the procedure produces an automaton with a more complex acceptance condition than the acceptance condition of the input automaton. Therefore we propose and implement an optimization, which prevents such a behavior and in general, produces smaller acceptance condition than the original one.

\begin{itemize}
    \item The selection of base of $\psi'$ is based on two keys. The primary key is cardinality (number of clauses) of $\overline{\psi_{i}}$, the secondary key is cardinality of clauses (number of terms in clause).
    \item We order the disjunct in every $\overline{\psi_{i}}$ in descending order, where the key is the cardinality of a particular disjunct.
    \item The DNF conversion of the input acceptance condition can lead to an exponential blowup of the formula, where some acceptance marks occur more than once. Since the reduction of acceptance sets is basically denoting the redundant ones as $\true$ or $\false$, we can as well easily obtain simplified acceptance formula in CNF (we simply denote the same acceptance sets as $\true$ or $\false$ as we did in DNF). According to the shape of the input acceptance condition, we choose the suitable (shorter) normal form and perform the merging algorithm on it.
\end{itemize}
By choosing the CNF over DNF in the cases where CNF is more natural (shorter), we prevent the formula to contain some acceptance marks more than once (at least, we do not create them by conversion of $\psi$ to DNF). This way, we prevent adding new acceptance marks to the formula when resolving conflicts of acceptance marks which leads to better results. If the original formula contains an acceptance mark that is present in more than one disjunct, then by ordering the disjuncts in every $\overline{\psi_{i}}$, the \emph{linear sum assignment} returns more convenient pairing. Meaning that if \emph{linear sum assignment} finds two equal assignments, it respects the order and the disjuncts with the  acceptance mark that occurs more than once are paired with disjuncts that also contain acceptance mark that occurs more than once.

\begin{example}
	Consider an automaton $\mathcal{A}$ in Figure \ref{fig:L1_before}. In this example, we demonstrate the simplification procedure described in Section \ref{section:simplification} and obtain simplified acceptance conditions $\psi_{i}$ for each SCC $S_{i}$. The simplified acceptance conditions $\overline{\psi_{i}}$ are displayed in the set-format we introduced earlier because we make use of it afterward during the merge. Then we merge these formulae into the acceptance condition of the simplified automaton $\mathcal{A}'$.
We enumerate the SCCs $S_{1}, S_{2}, S_{3}$. (The indices correspond with the numbers inside the states in Figure \ref{fig:L1_before}.) And we assign an accepting condition $\psi_{1}$ to $S_{1}$, $\psi_{2}$ to $S_{2}$ and $\psi_{3}$ to $S_{3}$.
    \begin{enumerate}
	    \item We simplify $\psi_{1}$ according to the placement of acceptance marks on the edges in $S_{1}$. At first we notice, that the formula $\overline{\psi_{1}}$ contains acceptance marks that are not present on the edges of $S_{1}$. Therefore modify $\overline{\psi_{1}}$ as described in Subsection \ref{subsection:acc_modif}. We substitute $\true$ for $\Fin\tacc{3}{3}$ and $\false$ for $\Inf\tacc{1}{1}$ and $\Inf\tacc{0}{0}$. (This substitution deletes the whole disjunct $D_{1}$.) Then we notice that the acceptance marks are in a position which allows us to perform the simplification described in first part of subsection 3.1.4. We substitute $\true $ for $\Inf\tacc{4}{4}$ and obtain the final form of $\overline{\psi_{1}} = \{\{ \Fin\tacc{2}{2}\} \}$.
	    \item Similarly as in previous case, we notice that acceptance marks $\tacc{2}{2}$, $\tacc{3}{3}$ and $\tacc{4}{4}$ are not present on the edges of $S_{2}$. Therefore we substitute $\true$ for both $\Fin\tacc{2}{2} \text{ and } \Fin\tacc{3}{3}$ and $\false$ for $\Inf\tacc{4}{4}$ (and thus remove the whole disjunct $D_{2}$).  Then we use the procedure described in Subsection \ref{subsection:simpl_inf} and remove $\Inf\tacc{1}{1}$ from the disjunct $D_{1}$ and obtain $\overline{\psi_{2}} = \{ \{\Inf\tacc{0}{0}\} \}$.
        \item Finally, we yet again remove marks that are not present in $S_{3}$ and perform the simplification described in subsection 3.1.3. We substitute $\true $ for $\Fin\tacc{2}{2} \text{ and } \Fin\tacc{3}{3}$ and add new term $\Fin\tacc{5}{5}$ into $D_{2}$ and place $\tacc{5}{5}$ on the edges that are labeled with $\tacc{2}{2}$ or $\tacc{3}{3}$. The simplified acceptance condition is $\overline{\psi_{3}} = \{\{ \Fin\tacc{5}{5}, \Inf\tacc{4}{4}\}\}$.
    \end{enumerate}

	Now we proceed to the merge of the formulae of the SCCs $\psi_{i}$. As a base of the new acceptance condition $\psi'$ we choose the formula $\psi_{3}$ because it has the highest number of disjuncts compared to the other formulae $\psi_i$, so $\overline{\psi'}=\{ \{ \Fin\tacc{5}{5}, \Inf\tacc{4}{4} \}\}$. Now we merge  $\psi_{1}$ and $\psi_{2}$ with $\psi'$. The order is in this particular case irrelevant because $\overline{\psi_{1}}$ has the same number of disjuncts as $\overline{\psi_{2}}$ (and both disjuncts have the same number of conjuncts). So we merge $\overline{\psi_{1}}$ at first because of its lower index. Since both $\overline{\psi'}$ and $\overline{\psi_{1}}$ have only one disjunct, the only possible pairing that \emph{linear sum assignment 
    } can give us is $(0,0)$, meaning that $\{ \Fin\tacc{2}{2}\}$ is merged with $\{ \Fin\tacc{5}{5}, \Inf\tacc{4}{4}\}$. Then we need to map an unused conjunct  $\Fin\tacc{5}{5}$ to a conjunct of the same type which is $\Fin\tacc{2}{2}$. Similarly in case of $\overline{\psi_{2}}$ we map $\Inf\tacc{4}{4}$ on $\Inf\tacc{0}{0}$. This way we produce $\mathcal{A}'$ displayed in Figure  \ref{fig:L1_middle} with the acceptance condition $ \Fin\tacc{5}{5} \land \Inf\tacc{4}{4}$. Observe that the automaton $\mathcal{A}'$ is not equivalent to the original $\mathcal{A}$. For example in Figure \ref{fig:L1_middle} is the highlighted loop not accepting but in the original automaton in Figure \ref{fig:L1_before} the loop accepting is. To reach the equivalence between the two automata, we need to \emph{restore equivalence} which is described in the next section.
\end{example}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[automaton]
			\node[flabel] at (2,5) {$( \Inf\tacc{0}{0} \land \Inf\tacc{1}{1}) \lor (\Fin\tacc{2}{2} \land \Fin\tacc{3}{3} \land \Inf\tacc{4}{4})$};

			\node[state, initial] (x) at (0,0) {0};
			\node[state] (y) at (2,2) {1};
			\node[state] (z) at (2,-1.5) {2};
			\node[state] (w) at (5,-1.5) {3};

			\path[->]
				(x) edge[]  (y)
				(x) edge[]  (z)
				(z) edge[] (w)
				
            	
            	(z) edge[loop, in = 75, out = 105, looseness=6] (z)
            	(z) edge[loop, in = 72, out = 108, looseness=9] (z)
            	(z) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc1] {1}(z)
            	(z) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc0, pos=0.6] {0} node[accset,collacc1, pos=0.4] {1}(z)
            	
            	(w) edge[loop, in = 75, out = 105, looseness=6] (w)
            	(w) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc3] {3}(w)
            	(w) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc2] {2}(w)
            	(w) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4}(w)
            	
            	(y) edge[loop, in = 75, out = 105, looseness=6] node[accset,collacc4] {4}(y)
            	(y) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc4] {4}(y)
            	(y) edge[loop, in = 70, out = 110, looseness=12] node[accset,collacc2] {2} (y)
            	(y) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc2] {2}(y)
            	
            	
			;
		\end{tikzpicture}
    \caption{TELA before simplification Level 1}
    \label{fig:L1_before}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[automaton]
			\node[flabel] at (2,5) {$ \Fin\tacc{5}{5} \land \Inf\tacc{4}{4}$};

			\node[state, initial] (x) at (0,0) {0};
			\node[state] (y) at (2,2) {1};
			\node[state] (z) at (2,-1.5) {2};
			\node[state] (w) at (5,-1.5) {3};

			\path[->]
				(x) edge[]  (y)
				(x) edge[]  (z)
				(z) edge[] (w)
				
            	
            	(z) edge[loop, in = 75, out = 105, looseness=6] (z)
            	(z) edge[loop, in = 72, out = 108, looseness=9] (z)
            	(z) edge[loop, in = 70, out = 110, looseness=12]  (z)
            	(z) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4} (z)
            	
            	(w) edge[loop, in = 75, out = 105, looseness=6] (w)
            	(w) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4}(w)
            	
            	(y) edge[loop, in = 75, out = 105, looseness=6, color=red] (y)
            	(y) edge[loop, in = 72, out = 108, looseness=9] (y)
            	(y) edge[loop, in = 70, out = 110, looseness=12] node[accset,collacc5] {5} (y)
            	(y) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc5] {5}(y)
            	
            	
			;
		\end{tikzpicture}
    \caption{TELA after simplification and merging in Level 1}
    \label{fig:L1_middle}
\end{figure}

\subsection{Restoring equivalence}
Replacing the input acceptance condition with $\psi'$ in $\mathcal{A}$ might change the language, so it is no longer equivalent to the language recognized by the original automaton $\mathcal{A}$. 
 By now, each SCC $S_{i}$ is adjusted to the acceptance condition $\psi_{i}$ which might be different than $\psi'$. 
 Therefore, for each SCC we need to restore equivalence with the new acceptance condition $\psi'$.
 The idea is that the only terms of $\psi'$ that can affect accepting runs on SCC $S_{i}$ are the ones that have been mapped on some terms in $\psi_{i}$. From now on, we refer to them as \emph{used terms}. We need to make sure that the other terms (the ones that have not been mapped on any term of $\psi_{i}$) can't affect any accepting run of $\mathcal{A}'$. From now on, we call these terms \emph{unused terms}.  We influence the evaluation of the  \emph{unused terms} in the following way:
\begin{itemize}
     \item If we want to make term in the $\Fin$ form always $\false$, we place it's acceptance mark on every edge of the SCC.
     \item If we want to make term in the $\Inf$ form always $\true$, we place it's acceptance mark on every edge of the SCC.
\end{itemize}
 Keep in mind that by now, any acceptance mark that is not in $\psi'$ is not present on any edge of $\mathcal{A}'$. Therefore any $\Fin$ term is already always $\true$ if its acceptance mark is not present on any edge of the SCC. Dually, $\Inf$ term is already always $\false$ if it is not present on any edge of the SCC.
\medskip
 Now we distinguish the cases when $\psi'$ is in DNF or $\psi'$ is in CNF. 
\begin{itemize}
     \item If $\psi'$ is in DNF, we need to make $\false $ every disjunct that does not contain any \emph{used term}. Further, every \emph{unused term} that occurs in the same disjunct as any \emph{used term} needs to be made $\true$. 
     \item Dually, if $\psi'$ is in CNF, every conjunct that does not contain any \emph{used term} needs to be made $\true$ and every \emph{unused term} that occurs in a conjunct with any \emph{used term} needs to be made $\false$.  
     
\end{itemize}
 
\begin{example}
	Consider the example from the Figure \ref{fig:L1_middle}, where the DNF acceptance condition $\psi' = (\Fin\tacc{5}{5} \lor \Inf\tacc{4}{4})$ and the acceptance condition of SCC $S_{1}$ $\psi_{1} = (\Fin\tacc{2}{2})$. The term $\Fin\tacc{5}{5}$ is mapped to $\Fin\tacc{2}{2}$. Then we need to enforce that the \emph{unused term} $\Inf\tacc{4}{4}$ has no effect on the evaluation of $\psi'$ by the run with the infinite suffix contained within the SCC $S_{1}$. Otherwise the result will not be equivalent (see the highlited loop in Figure \ref{fig:L1_middle}). Therefore we make term $\Inf\tacc{4}{4}$ $\true$ by adding $\tacc{4}{4}$ on every edge of the SCC $S_{i}$. The result can be seen in Figure \ref{fig:L1_done}.
\end{example}
 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[automaton]
			\node[flabel] at (2,5) {$ \Fin\tacc{5}{5} \land \Inf\tacc{4}{4}$};

			\node[state, initial] (x) at (0,0) {0};
			\node[state] (y) at (2,2) {1};
			\node[state] (z) at (2,-1.5) {2};
			\node[state] (w) at (5,-1.5) {3};

			\path[->]
				(x) edge[]  (y)
				(x) edge[]  (z)
				(z) edge[] (w)
				
            	
            	(z) edge[loop, in = 75, out = 105, looseness=6] (z)
            	(z) edge[loop, in = 72, out = 108, looseness=9] (z)
            	(z) edge[loop, in = 70, out = 110, looseness=12]  (z)
            	(z) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4} (z)
            	
            	(w) edge[loop, in = 75, out = 105, looseness=6] (w)
            	(w) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4}(w)
            	
            	(y) edge[loop, in = 75, out = 105, looseness=6] node[accset,collacc4] {4} (y)
            	(y) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc4] {4}(y)
            	(y) edge[loop, in = 70, out = 110, looseness=12] node[accset,collacc4, pos=0.4] {4} node[accset,collacc5, pos=0.6] {5}(y)
            	(y) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4, pos=0.4] {4} node[accset,collacc5, pos=0.6] {5}(y)
            	
            	
			;
		\end{tikzpicture}
    \caption{Equivalent TELA after simplification Level 1}
    \label{fig:L1_done}
\end{figure}

%}}}



%%% Local Variables:
%%% mode: latex
%%% End:
