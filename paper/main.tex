% vim: tw=78 ai spell spelllang=en

\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

\bibliographystyle{plainurl}% the mandatory bibstyle
\nolinenumbers

\usepackage{multirow}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{makecell}
\usepackage[table]{xcolor}
%\usepackage{arydshln}
%\newcommand\VRule[1][\arrayrulewidth]{\vrule width #1}
\usepackage[noend]{algorithm2e}
\usepackage{amsmath,amssymb}
%\usepackage{enumerate}
\usepackage{tablefootnote}

\usepackage{tikz}
% TikZ libraries
\usetikzlibrary{myautomata}
\usetikzlibrary{fit, backgrounds}
\usetikzlibrary{extshapes}

\usepackage{pgfplots}
\pgfplotsset{compat=newest}

%{{{ (La)TeX definitions

\newcommand{\Nset}{{\mathbb{N}_0}}
\newcommand{\todo}[1]{\marginpar{\textcolor{red}{#1}}}
\newcommand{\fixme}[1]{\textcolor{red}{#1}}
%\newcommand{\todo}[1]{}
%\def\Inf{\ensuremath{\mathsf{Inf}}}
%\def\Fin{\ensuremath{\mathsf{Fin}}}
\DeclareMathOperator{\Inf}{\mathsf{Inf}}
\DeclareMathOperator{\Fin}{\mathsf{Fin}}
\newcommand{\minf}{\mathit{inf}}
\newcommand{\mks}{\mathit{mks}}
%\newcommand{\oM}{\widehat{M}}
\newcommand{\oM}{N}
\newcommand{\rem}{\mathit{nm}}
\newcommand{\mcycle}{\mathit{cycle}}
\newcommand{\msat}{\mathit{satisfies}}
\newcommand{\Te}{T_{\vec{e}}}
% \newcommand{\pre}{{\leftarrow\!\!S}}
% \newcommand{\post}{{S\!\!\rightarrow}}
\newcommand{\pre}{{S_\mathit{pre}}}
\newcommand{\post}{{S_\mathit{post}}}
\def\false{\mathit{false}}
\def\true{\mathit{true}}
\newcommand{\mA}{\mathcal{A}}
\newcommand{\mB}{\mathcal{B}}
\newcommand{\bigO}{\mathcal{O}}

\newcommand{\telatko}{\texttt{telatko}\xspace}

% setting the color of comments in algorithm
\definecolor{algoColorComment}{RGB}{204, 51, 0}
\definecolor{algoColorComment2}{RGB}{204, 153, 102}
\newcommand{\decmt}[1]{{\color{algoColorComment2}\texttt{#1}}}
\SetCommentSty{decmt}

%}}}
%{{{ hyperref and ORCID ref

% \makeatletter
% \RequirePackage[bookmarks,unicode,colorlinks=true]{hyperref}%
%    \def\@citecolor{blue}%
%    \def\@urlcolor{blue}%
%    \def\@linkcolor{blue}%
% \def\UrlFont{\rmfamily}
% \def\orcidID#1{\smash{\href{http://orcid.org/#1}{\protect\raisebox{-1.25pt}{\protect\includegraphics{orcid_color.eps}}}}}
% \makeatother

% \usepackage{academicons}
% \definecolor{orcidlogocol}{HTML}{A6CE39}

%}}}

%{{{ title and authors

\title{Reducing Acceptance Marks in Emerson-Lei Automata by QBF Solving}
\author{Tereza Schwarzov\'{a}}{%Faculty of Informatics,
  Masaryk University, Brno, Czech Republic}{xschwar3@mail.muni.cz}{https://orcid.org/0009-0001-9016-5399}{}
\author{Jan Strej\v{c}ek}{%Faculty of Informatics,
  Masaryk University, Brno, Czech Republic}{strejcek@fi.muni.cz}{https://orcid.org/0000-0001-5873-403X}{}
\author{Juraj Major}{%Faculty of Informatics,
  Masaryk University, Brno, Czech Republic}{major@fi.muni.cz}{https://orcid.org/0009-0007-1871-9047}{}
\authorrunning{T. Schwarzov\'{a}, J. Strej\v{c}ek, and J. Major}
\Copyright{Tereza Schwarzov\'{a}, Jan Strej\v{c}ek, and Juraj Major}
\ccsdesc[500]{Theory of computation~Logic}
\ccsdesc[500]{Theory of computation~Automata over infinite objects}
\keywords{Emerson-Lei automata, TELA, automata reduction, QBF, telatko}
\funding{T.~Schwarzová received funding from
the European Union’s Horizon Europe program under the Grant Agreement
No.\ 101087529.}

%}}}

\EventEditors{Meena Mahajan and Friedrich Slivovsky}
\EventNoEds{2}
\EventLongTitle{26th International Conference on Theory and Applications of Satisfiability Testing (SAT 2023)}
\EventShortTitle{SAT 2023}
\EventAcronym{SAT}
\EventYear{2023}
\EventDate{July 4--8, 2023}
\EventLocation{Alghero, Italy}
\EventLogo{}
\SeriesVolume{271}
\ArticleNo{22}

\begin{document}

\maketitle

%{{{ abstract

\begin{abstract}
  This paper presents a novel application of QBF solving to automata
  reduction. We focus on \emph{Transition-based Emerson-Lei automata
    (TELA)}, which is a popular formalism that generalizes many
  traditional kinds of automata over infinite words including Büchi,
  co-Büchi, Rabin, Streett, and parity automata. Transitions in a TELA
  are labelled with acceptance marks and its accepting formula is a
  positive Boolean combination of atoms saying that a particular mark
  has to be visited infinitely or finitely
  often. % in an accepting run.
  Algorithms processing these automata are often very sensitive to the
  number of %different
  acceptance marks. We introduce a new technique for reducing the
  number of %different
  acceptance marks in TELA based on satisfiability of \emph{quantified
    Boolean formulas (QBF)}.
  % : if a constructed QBF formula is satisfiable then
  % its model encodes an equivalent accepting formula with less
  % acceptance marks.
  %
  % In fact, we present three formula constructions
  % % trading speed for higher reduction efficiency.
  % with increasing reduction potential and formula complexity, and thus
  % also decreasing speed of their satisfiability solving.
  We evaluated our reduction technique on TELA produced by
  state-of-the-art tools of the libraries Owl and Spot and by the tool
  \texttt{ltl3tela}. The technique reduced some acceptance marks in
  automata produced by all the tools. On automata with more than one
  acceptance mark obtained by translation of LTL formulas from
  literature with tools Delag and Rabinizer~4, our
  technique reduced 27.7\% and 39.3\% of acceptance marks,
  respectively. The reduction was even higher on automata from random
  formulas.
  % The achieved
  % reduction of acceptance marks on automata produced by tools of the Owl library was
  % between 25 and 40\%.
\end{abstract}

%}}}

%{{{ introduction

\section{Introduction}

Automata over infinite words like Büchi, Rabin, Streett, or parity
automata play a crucial role in many algorithms related to 
concurrency theory, game theory, and formal methods in general. In
particular, they are used in specification, verification, analysis,
monitoring, and synthesis of various systems with infinite
behaviour. In 1987, Emerson and Lei~\cite{emerson.87.scp} introduced
automata over infinite words where acceptance conditions are arbitrary
combinations of acceptance primitives saying that a certain set of
states should be visited finitely often or infinitely often. In 2015,
the same kind of acceptance condition was described in the \emph{Hanoi
  omega-automata format (HOAF)}~\cite{babiak.15.cav}. The only
difference is that the acceptance primitives talk about finitely or
infinitely often visited acceptance marks rather than sets of states.
Acceptance marks are placed on transitions and each mark identifies
the set of transitions containing this mark. Hence, these automata are
called \emph{transition-based Emerson-Lei automata (TELA)} and they
generalize many traditional kinds of automata over infinite words
including Büchi, co-Büchi, Rabin, Streett, and parity automata.

TELA have attracted a lot of attention during the last few
years~\cite{baier.19.atva,major.19.atva,muller.17.gandalf,renkin.20.atva}.
Their popularity comes probably from the fact that these automata can
often use fewer states than equivalent automata with simpler
acceptance conditions. Further, algorithms handling TELA can
automatically handle all automata with traditional acceptance
conditions. TELA can be obtained for example by translating formulas
of \emph{linear temporal logic (LTL)}~\cite{pnueli.77.focs} with tools
\texttt{ltl2dela} (known as Delag)~\cite{muller.17.gandalf} or
\texttt{ltl2dgra} (known as Rabinizer~4)~\cite{kretinsky.18.cav} of
the Owl library, \texttt{ltl2tgba} of the Spot
library~\cite{duret.16.atva2}, or
\texttt{ltl3tela}~\cite{major.19.atva}. There are also algorithms
processing these automata, for example the emptiness
check~\cite{baier.19.atva} or translation of TELA to parity
automata~\cite{renkin.20.atva,casares.22.tacas}.

Algorithms processing TELA are often sensitive to the number of
acceptance marks more than to other parts of the automaton. For
example, the transformation of TELA to parity automata based on
\emph{color appearance record}~\cite{renkin.20.atva} transforms a TELA
with $m$ acceptance marks and $s$ states into a parity automaton with
up to $m!\cdot s$ states. Further, the emptiness-check
algorithm~\cite{baier.19.atva} is exponential in the number of
acceptance marks that appear in acceptance primitives saying that a
mark has to be visited finitely often, while it is only polynomial in
other measures of the input automaton.

The number of acceptance marks can be algorithmically reduced to one
as every TELA can be transformed to an equivalent Büchi automaton
(this can be easily done for example by Spot~\cite{duret.16.atva2}),
but this reduction is paid by dramatic changes of state space: the
number of states can increase exponentially in the number of
acceptance marks and some important structural properties like
determinism can be lost. This motivates our study of a technique
reducing the number of acceptance marks without altering the structure
of the automaton.

Our reduction technique is heavily based on \emph{quantified Boolean
  formulas (QBF)}. For a given TELA and parameters $C,K$, it produces
a QBF which is satisfiable if and only if there exists an
automaton with the same structure, $K$ acceptance marks, an acceptance
formula in disjunctive normal form with $C$ cubes (i.e., conjunction
of literals), and the same set of accepting runs as the original
automaton. The placement of the marks on transitions and the
acceptance formula can be obtained from a model of the
formula. Besides this formula, we describe also the construction of
two simpler formulas whose satisfiability implies the existence of an
automaton with the same structure, $K$ acceptance marks, and the same
set of accepting runs, but not vice versa.

We have implemented our reduction technique in a tool called
\telatko. We show that the tool can reduce acceptance marks in
automata produced by Delag~\cite{muller.17.gandalf},
Rabinizer~4~\cite{kretinsky.18.cav} (both included in the Owl
library), Spot~\cite{duret.16.atva2}, and
\texttt{ltl3tela}~\cite{major.19.atva}.  While the reduction is
relatively modest on TELA produced by \texttt{ltl3tela} and Spot, it
is substantial on automata produced by the tools of the Owl library.

\paragraph*{Related results}
There is a simple technique~\cite{babiak.13.spin} reducing the number
of acceptance marks in \emph{transition-based generalised Büchi
  automata (TGBA)} without changing its structure. We are not aware
of any existing research aimed at simplification of acceptance
formulas of TELA or reduction of the number of its acceptance marks
without increasing the number of states. There exists only a SAT-based
approach that transforms a deterministic TELA to an
equivalent automaton with a given acceptance condition and a given
number of states~\cite{baarir.15.lpar} (if such an automaton
exists). Further, there are some SAT-based approaches aimed to reduce
the number of states of automata over infinite words. More precisely,
there are reductions designed for nondeterministic Büchi
automata~\cite{ehlers.10.spin}, deterministic Büchi
automata~\cite{ehlers.10.sat}, and deterministic generalized Büchi
automata~\cite{baarir.14.forte}. Note that these techniques are
usually very slow and their authors typically suggest to use them only
for specific purposes like looking for cases where some automata
construction can be improved.

Casares, Colcombet, and Fijalkow very recently introduced a structure
called \emph{alternating cycle decomposition
  (ACD)}~\cite{casares.21.icalp} which compactly represents
%the information about
all accepting and non-accepting automata cycles. We
expect that ACD could %potentially
be used to reduce the number of
acceptance marks or to simplify the acceptance condition. However,
such a reduction is not obvious.
%Moreover, the construction of ACD seems to be computationally expensive.

\paragraph*{Structure of the paper} The next section introduces basic
terms used in the paper. Section~\ref{sec:qbf} explains the
construction of the three mentioned quantified Boolean formulas. The
reduction algorithm based on these formulas is presented in
Section~\ref{sec:algo}. Section~\ref{sec:implementation} describes our
tool \telatko implementing the reduction technique.  Experimental
results are shown in Section~\ref{sec:experiments}. Finally,
Section~\ref{sec:conclusion} suggests other applications of our
QBF-based reduction technique and closes the paper.

%}}}
%{{{ preliminaries

\section{Preliminaries}\label{sec:prelim}

In this section we recall the basic terms related to TELA and QBF.

\begin{definition}[TELA]
  A \emph{transition-based Emerson-Lei automaton (TELA)} is a tuple
  $\mA =(Q,M,\Sigma,\delta,q_I,\varphi)$, where
  \begin{itemize}
  \item $Q$ is a finite set of \emph{states},
  \item $M$ is a finite set of \emph{acceptance marks},
  \item $\Sigma$ is a finite \emph{alphabet},
  \item $\delta \subseteq Q \times \Sigma \times 2^{M} \times Q$ is a
    \emph{transition relation},
  \item $q_I\in Q$ is an \emph{initial state}, and
  \item $\varphi$ is the \emph{acceptance condition} constructed
    according to the following abstract syntax equation, where $m$
    ranges over $M$.
    $$\varphi ::= \true \mid \false \mid \Inf m \mid \Fin m \mid \left( \varphi \land \varphi \right) \mid \left( \varphi \lor \varphi \right)$$
\end{itemize}
\end{definition}

A tuple $t=(p,a,M',q)\in\delta$ is the \emph{transition} leading from
state $p$ to state $q$ labelled with $a$ and acceptance marks $M'$.
The set $M'$ is also referred to by $\mks(t)$. For a set of transitions
$T\subseteq\delta$, let $\mks(T)=\bigcup_{t\in T}\mks(t)$ denote the
set of marks that appear on transitions in $T$.
% of various objects:
% \begin{itemize}
% \item for a transition $t=(p,a,M',q)\in\delta$, $\mks(t)$ denotes the set $M'$,
% \item for a set $T\subseteq\delta$ of transitions,
%   $\mks(T)=\bigcup_{t\in T}\mks(t)$ denotes the set of marks that appear on
%   transitions in $T$,
% \item for a run $\pi$, $\mks(\pi)=\mks(\minf(\pi))$ denotes the set of
%   marks that occur in infinitely many transitions of run $\pi$.
% \end{itemize}

A \emph{run} $\pi$ of $\mA$ over an infinite word
$u = u_{0}u_{1}u_{2}\ldots \in \Sigma^{\omega}$ is an infinite sequence
of adjacent transitions
$\pi=(q_0,u_0,M_0,q_1)(q_1,u_1,M_1,q_2)\ldots\in\delta^{\omega}$ where
$q_0=q_I$. Let $\minf(\pi)$ denote the set of transitions that appear
infinitely many times in $\pi$. Run $\pi$ is \emph{accepting} iff
$\minf(\pi)$ satisfies the formula $\varphi$, where a set $T$ of
transitions satisfies $\Inf m$ iff $m\in\mks(T)$ and it satisfies
$\Fin m$ iff $m\not\in\mks(T)$. The \emph{language} of $\mA$ is
the set
$L(\mA)=\{u\in \Sigma^{\omega}\mid\textrm{there is an accepting run of
}\mA\textrm{ over }u\}$. Two automata $\mA,\mB$ are \emph{equivalent}
if $L(\mA)=L(\mB)$.
% such that $\mA$ has
% an accepting run over $u$.

An acceptance formula $\varphi$ is in \emph{disjunctive normal form
  (DNF)} if it is a disjunction of cubes, where each cube is a
conjunction of atoms of the form $\Fin m$ or $\Inf m$.  Each
acceptance formula can be transformed into an equivalent formula
in~DNF. Formula $\false$ corresponds to the disjunction of zero
cubes and formula $\true$ corresponds to the cube with zero atoms.

A \emph{path} from a state $p$ to a state $q$ is a finite sequence of
adjacent transitions of the form
$\rho=(q_0,u_0,M_0,q_1)(q_1,u_1,M_1,q_2)\ldots(q_{n-1},u_{n-1},M_{n-1},q_n)\in\delta^+$
such that $p=q_0$ and $q=q_n$. A nonempty set of states $S\subseteq Q$
is called a nontrivial \emph{strongly connected component (SCC)} if
for each $p,q\in S$ there is a path from $p$ to $q$. An SCC S is
\emph{maximal} if there is no SCC $S'$ satisfying $S\subsetneq S'$. In
the rest of this paper, SCC always refers to a maximal SCC. Given a
set of states $S\subseteq Q$, let $\delta_S=\delta\cap (S\times \Sigma \times 2^M \times S)$
denote the set of all transitions between states in $S$. Further, for
each mark $m\in M$, let $\delta_m=\{t\in\delta\mid m\in
\mks(t)\}$ denote the set of all transitions
marked with $m$.
% \todo{The sets $\delta_m$ are called \emph{acceptance sets}. Given
% an SCC $S$ and a mark $m\in M$, by $\delta_{S,m}$ we denote the set
% $\delta_{S,m}=\delta_S\cap\delta_m$.}
A set of transitions $T\subseteq\delta$ is called a \emph{cycle} if
there exists a path from a state $p$ to the same state containing each
transition of $T$ at least once and no transition outside
$T$. Finally, we assume that each TELA $\mA$ contains only states $q$
that are reachable from the initial state $q_I$ (i.e., $q=q_I$ or
there is a path from $q_I$ to $q$) as states that are not reachable
from $q_I$ can be eliminated without any impact on $L(\mA)$. We also
assume that each TELA has at least one SCC as automata without any SCC
trivially describe an empty language.

In graphical representation, we often use acceptance marks
$\tacc{1}{1},\tacc{2}{2},\ldots\in M$. Further, an edge 
\begin{tikzpicture}[smallautomaton,baseline=-2pt]
  \node[state] (p) at (0,0) {$p$};
  \node[state] (q) at (1.8,0) {$q$};
  \path [->] (p) edge node[above,pos=.5,overlay] {$a$} node[accset,collacc8, pos=0.65] {k} node[accset,collacc4, pos=0.3] {j} (q);
\end{tikzpicture}
denotes the transition $(p,a,\{\tacc{4}{j},\tacc{8}{k}\},q)\in\delta$. 

By choosing an appropriate acceptance condition, one can easily
represent many classical kinds of automata over infinite words. For
example, a Büchi automaton can be represented as a TELA with the
acceptance condition $\varphi = \Inf\tacc{1}{1}$ and the single mark
$\tacc{1}{1}$ placed on all transitions leaving the accepting states
of the Büchi automaton. Further, a Rabin automaton with $k$ acceptance
pairs can be similarly represented as a TELA with acceptance condition
$\varphi = (\Fin\tacc{5}{1} \land \Inf\tacc{3}{1'}) \lor \ldots \lor
(\Fin\tacc{5}{k} \land \Inf\tacc{3}{k'})$ and marks
$M = \{\tacc{5}{1}, \tacc{3}{1'}, \ldots, \tacc{5}{k},
\tacc{3}{k'}\}$.

\bigskip

\emph{Quantified Boolean formulas (QBF)} are Boolean formulas
extended with universal and existential quantification over
propositional variables. We assume that subformulas of the form
$\forall x.\psi$ and $\exists x.\psi$ do not contain another
quantification of variable $x$ inside $\psi$. The semantics of
$\forall x.\psi$ and $\exists x.\psi$ is given by equivalences
\[
  \begin{array}{rcl}
    \forall x.\psi &~\equiv~& \psi[x\rightarrow\true]~\wedge~\psi[x\rightarrow\false]\\
    \exists x.\psi &~\equiv~& \psi[x\rightarrow\true]~\vee~   \psi[x\rightarrow\false]
  \end{array}
\]
where $\psi[x\rightarrow \rho]$ denotes the formula $\psi$ with all
occurrences of $x$ simultaneously replaced by $\rho$. The equivalences
imply that each QBF can be transformed into an equivalent Boolean
formula. However, the size of this Boolean formula can be exponential
in the size of the original QBF. Let $V$ be the set of all
propositional variables. A mapping $\mu:V\rightarrow\{0,1\}$
is a \emph{model} of a QBF $\varphi$ iff it is a satisfying
assignment of an equivalent Boolean formula. A QBF is
\emph{satisfiable} iff it has a model.

% A QBF $\varphi$ is in the \emph{prenex normal form} if it has the form
% $\varphi = Q_{1}x_{1}...Q_{n}x_{n} . \psi$, where
% $Q_1,\ldots,Q_n \in \{\forall, \exists\}$ and $\psi$ is a Boolean
% formula.

%}}}
%{{{ construction of QBF formulas

\section{Construction of quantified Boolean formulas}\label{sec:qbf}

Recall that we aim to reduce the number of acceptance marks in a given
TELA $\mA =(Q,M,\Sigma,\delta,q_I,\varphi)$ without altering its
structure and language. In other words, we look for
\begin{itemize}
\item a set $\oM$ of acceptance marks satisfying $|\oM|<|M|$,
\item an acceptance formula $\psi$ over $\oM$, and 
\item a function
  $\rem:\delta\rightarrow Q \times \Sigma \times 2^{\oM}\times Q$
  assigning new marks to transitions (i.e., for each
  $t=(p,a,M',q)\in\delta$, we assume that $\rem(t)=(p,a,\oM',q)$ for
  some $\oM'\subseteq\oM$)
  %
  such that the automaton $\mB=(Q,\oM,\Sigma,\rem(\delta),q_I,\psi)$
  is equivalent to $\mA$.
\end{itemize}
% To simplify the task, 
% To ensure that the modified automaton is equivalent to the original one,
We will actually look for $\psi$ and $\rem$ such that each run
$\pi=t_0t_1t_2\ldots$ of $\mA$ is accepting if and only if the run
$\rem(t_0)\rem(t_1)\rem(t_2)\ldots$ of $\mB$ is accepting. This
requirement clearly guarantees the equivalence of $\mA$ and $\mB$,
but it is not a necessary condition for the equivalence. Indeed, there
exist automata where relaxing this requirement can lead to a bigger
reduction of acceptance marks (see Figure~\ref{fig:counter}). However,
looking for $\psi$ and $\rem$ that preserve the acceptance of individual
runs makes the problem easier as we can, for example, ignore the
labelling of transitions by the elements of $\Sigma$.
\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=180,xshift=-3.5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=120,in=60,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=-60,in=-120,looseness=10] pic {acc={1}{1}} pic {l=$b$} (p)
      (p) edge[out=30,in=150] pic {l=$a$} (q)
      (q) edge[out=-150,in=-30] pic {l=$b$} (p);

      \node[acclabel] at (1,-1.7)
      {$\Inf\tacc{0}{0}\wedge\Inf\tacc{1}{1}$};
    \end{scope}
    \begin{scope}[initial angle=180,xshift=3.5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=120,in=60,looseness=10] pic {l=$a$} (p)
      (p) edge[out=-60,in=-120,looseness=10] pic {l=$b$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$a$} (q)
      (q) edge[out=-150,in=-30] pic {l=$b$} (p);

      \node[acclabel] at (1,-1.7)
      {$\Inf\tacc{0}{0}$};
    \end{scope}
  \end{tikzpicture}
  \smallskip
  
  \caption{The left automaton accepts the words % $w\in\{a,b\}^\omega$
    that contain infinitely many occurrences of both $a$ and $b$. Each
    accepting run of the left automaton has to contain infinitely many
    occurrences of both transitions looping on the initial
    state. Hence, there does not exist any automaton with the same
    accepting runs as the left automaton and less than two acceptance
    marks. The right automaton accepts the same language using one
    acceptance mark and a different set of accepting runs.}
  \label{fig:counter}
\end{figure}

Our reduction method is based on two facts. First, the acceptance of a
run $\pi$ is fully determined by $\minf(\pi)$. Second, each set
$\minf(\pi)$ is a cycle and vice versa.

% Before we We start with a reformulation of our requirement on $\psi$
% and $\rem$.  Recall that a run $\pi$ of $\mA$ is accepting if and
% only iff $\minf(\pi)$ satisfies $\varphi$.  Further, the following
% lemma says that each set $\minf(\pi)$ is a cycle and vice versa.

\begin{lemma}
  A set $T\subseteq\delta$ is a cycle if and only if
  there is a run $\pi$ such that $\minf(\pi)=T$.
\end{lemma}
\begin{proof}
  To prove the direction `$\Longrightarrow$', we assume that $T$ is a
  cycle. The definition says that there exists a path $\tau$ from a
  state $p$ to the same state containing each transition of $T$ at
  least once and no transition outside $T$. As our automata contain
  only reachable states, there exists a path $\rho$ from the initial
  state $q_I$ to $p$ or $p=q_I$ and we set $\rho=\varepsilon$. The
  infinite sequence $\pi=\rho.\tau^\omega$ is a run satisfying
  $\minf(\pi)=T$.

  To prove the direction `$\Longleftarrow$', we consider a run
  $\pi$.  As $\minf(\pi)$ is the set of transitions that appear
  infinitely many times in $\pi$, there has to be a suffix $\pi'$ of
  $\pi$ containing only transitions of $\minf(\pi)$. Let $p$ be the
  first state of $\pi'$. As each transition of $\pi'$ appears
  infinitely many times in $\pi$ and thus also in $\pi'$, there has to
  be a finite prefix $\rho$ of $\pi'$ such that $\rho$ is a path from
  $p$ to $p$ that contains all transitions of $\minf(\pi)$. In other
  words, the set $\minf(\pi)$ is a cycle.
\end{proof}

Hence, our goal can be reformulated as follows. We look for a new
acceptance formula $\psi$ and a function $\rem$ such that for each
cycle $T\subseteq\delta$, it holds that $T$ satisfies $\varphi$ if and
only if $\rem(T)$ satisfies $\psi$. This can be roughly denoted by the
formula
\[
  \forall T\subseteq\delta~.~\mcycle(T)\implies\big(\msat_\varphi(T) ~\iff~ \msat_{\psi}(\rem(T))\big).
\]
In fact, this corresponds to the shape of the QBF we will
construct. As we are looking for $\psi$ and $\rem$ such that the
formula holds, the subformula $\msat_{\psi}(\rem(T))$ contains many
free variables representing possible instances of $\psi$ and
$\rem$. If the formula is satisfiable, then each of its models encodes
a desired instance of $\psi$ and $\rem$. In the following, we assume
that we are looking for a new acceptance formula $\psi$ in DNF. The
choice of DNF is not fundamental, but inherited from our previous
attempt to reduce acceptance formulas. The presented method can be
easily adapted to look for $\psi$ in \emph{conjunctive normal form
  (CNF)} or in a different shape.

Now we describe the construction of the QBF in detail. The
construction is parameterized by two integers $C,K\ge 0$, where $K$ is
the desired number of acceptance marks and $C$ is the number of cubes
of $\psi$. Without loss of generality, we assume that the reduced
automaton will use the acceptance marks $N_K=\{1,2,\ldots,K\}$.
%Further, we consider only subsets $T\subseteq\bigcup_{\textrm{SCC}~S}\delta_S$
We start with a description of Boolean variables used in the
constructed QBF.
\begin{itemize}
\item For each transition $t\in\delta$, variable $e_t$ says whether
  $t$ is in the current set $T$ or not.
  \[e_t=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if }t\in T\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
%  In fact, we consider variables 
\item For each transition $t\in\delta$ and acceptance mark $k\in N_K$,
  variable $n_{t,k}$ says whether $k$ is on the transition
  $\rem(t)$ or not.
  \[n_{t,k}=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if }k\in\mks(\rem(t))\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
\item For each $c\in\{1,2,\ldots,C\}$ and acceptance mark $k\in N_K$,
  variables $i_{c,k}$ and $f_{c,k}$ say whether the $c^\textrm{th}$
  cube of $\psi$ contains atoms $\Inf k$ or $\Fin k$, respectively.
  \[i_{c,k}=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if the $c^\textrm{th}$ cube of $\psi$ contains $\Inf k$}\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
  \[f_{c,k}=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if the $c^\textrm{th}$ cube of $\psi$ contains $\Fin k$}\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]

\end{itemize}
By $\vec{e},\vec{n},\vec{i},\vec{f}$ we denote the vectors of all
variables of the form $e_t$, $n_{t,k}$, $i_{c,k}$, and $f_{c,k}$,
respectively. The constructed QBF have the form
\[
  \Phi_{C,K}(\vec{n},\vec{i},\vec{f})~~=~~\forall \vec{e}~.~\mcycle(\vec{e})\implies\big(\msat_\varphi(\vec{e}) \iff \msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})\big),
\]
where $\forall\vec{e}$ denotes the sequence composed of $\forall e_t$
for all variables $e_t$. Now we define the subformulas
$\msat_\varphi(\vec{e})$,
$\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$, and three versions of
$\mcycle(\vec{e})$.

The subformula $\msat_\varphi(\vec{e})$ says whether $T$ satisfies the
original acceptance formula $\varphi$ and it is derived directly from
$\varphi$. Recall that $T$ satisfies $\Inf m$ iff $m\in\mks(T)$, which
means that $T$ contains some transition with mark $m$. As the
transitions with mark $m$ form the set $\delta_m$, $\Inf m$ can be
expressed by $\bigvee_{t\in\delta_m}e_t$. Similarly, $T$ satisfies
$\Fin m$ iff $m\not\in\mks(T)$, which can be expressed by
$\bigwedge_{t\in\delta_m}\neg e_t$. Hence, $\msat_\varphi(\vec{e})$
arises from $\varphi$ by replacing
\begin{itemize}
\item all atoms of the form $\Inf m$ by $\bigvee_{t\in\delta_m}e_t$ and
\item all atoms of the form $\Fin m$ by $\bigwedge_{t\in\delta_m}\neg e_t$.
\end{itemize}

Next, we construct the subformula
$\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ that evaluates to true
iff $\rem(T)$ satisfies~$\psi$. The subformula reflects the basic
structure of $\psi$. As we assume that $\psi$ is a disjunction of $C$
cubes, we have
\[
  \msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})=\bigvee_{c\in\{1,2,\ldots,C\}}\xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})
\]
where each $\xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ corresponds to
one cube. Recall that the presence of atoms $\Inf k$ and $\Fin k$ in
the $c^\textrm{th}$ cube is given by variables $i_{c,k}$ and
$f_{c,k}$, respectively. $\Inf k$ is satisfied by $\rem(T)$ iff $T$
contains a transition $t$ such that $k\in\mks(\rem(t))$, which can be
expressed as $\bigvee_{t\in\delta}(e_t\wedge n_{t,k})$. Similarly,
$\Fin k$ is satisfied by $\rem(T)$ iff there is no transition $t\in T$
such that $k\in\mks(\rem(t))$, which can be expressed as
$\bigwedge_{t\in\delta}\neg(e_t\wedge n_{t,k})$. Hence, we set
\[
  \xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})=
  \bigwedge_{k\in N_K}\Big(i_{c,k}\implies\bigvee_{t\in\delta}(e_t\wedge n_{t,k})\Big)\wedge\Big(f_{c,k}\implies\bigwedge_{t\in\delta}\neg(e_t\wedge n_{t,k})\Big).
\]

It remains to define the subformula $\mcycle(\vec{e})$. Let $\Te$
denote the set of transitions represented by $\vec{e}$. The original
intended meaning of $\mcycle(\vec{e})$ is
\[
  \mcycle(\vec{e}) \iff \Te\textrm{ is a cycle}.
\]
In fact, only the direction ``$\Longleftarrow$'' is needed for the
correctness of our reduction method. If there are some valuations of
$\vec{e}$ such that $\mcycle(\vec{e})$ holds and $\Te$ is not a cycle,
then we will superfluously require the equivalence
$\msat_\varphi(\vec{e}) \iff
\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ on these valuations.
% adds a superfluous constraint on $\psi$ (represented by
% $\vec{i},\vec{f}$) and $\rem$ (represented by $\vec{n}$).
These superfluous constraints can lead to loss of reduction
opportunities, but not to incorrectness. This observation allows us to
trade the precision of $\mcycle(\vec{e})$ for its simplicity.

We define three versions of $\mcycle(\vec{e})$:
\begin{itemize}
\item $\mcycle_1(\vec{e})$ is a lightweight version, which only says
  that $\Te$ is nonempty and $\Te\subseteq\delta_S$ for some SCC $S$.
  Except for SCCs, it does not use the information about the automaton
  structure, but it comes with an interesting simplification of the
  whole formula $\Phi_{C,K}$.
\item $\mcycle_2(\vec{e})$ is an intermediate version. It says that
  $\Te$ is nonempty, $\Te\subseteq\delta_S$ for some SCC $S$, and
  every transition in $\Te$ has % to have
  a preceding and a succeeding transition in $\Te$, which is a
  necessary condition for being a cycle, but not a sufficient one.
\item $\mcycle_3(\vec{e})$ is a strict version saying that $\Te$ is a
  cycle. Unfortunately, it uses additional universally quantified
  variables corresponding to automata states. Transformation of
  $\Phi_{C,K}$ to prenex normal form turns the quantifiers to
  existential ones and the resulting formula thus contains quantifier
  alternation.
\end{itemize}
We write $\Phi_{j,C,K}$ % where $j\in\{1,2,3\}$
when we want to emphasize
that a particular formula $\Phi_{C,K}$ contains the version
$\mcycle_j(\vec{e})$.

\subsection{Lightweight version $\mcycle_1(\vec{e})$}
The lightweight version is defined as
% \[
%   \mcycle_1(\vec{e})=\bigvee_{t\in\delta}e_t
% \]
% which means only that $\Te$ is nonempty.
\[
  \mcycle_1(\vec{e})=\bigvee_{\text{SCC } S}~~\big(\bigvee_{t\in\delta_S}e_t ~~\wedge \bigwedge_{t'\in\delta\smallsetminus\delta_S}\neg e_{t'}\big)
\]
which means only that $\Te$ is nonempty and $\Te\subseteq\delta_S$ for
some SCC $S$.
This condition is satisfied by every cycle.

The formula $\Phi_{1,C,K}$ built with $\mcycle_1(\vec{e})$ says that
for every nonempty set $T\subseteq\delta_S$ where $S$ is an SCC, $T$
satisfies $\varphi$ if and only if $\rem(T)$ satisfies $\psi$. Note
that the only aspects of a transition $t$ reflected by the formula are
its set of marks $\mks(t)$ and its affiliation to an SCC.
% In partcular, it is not affected by its placement inside the
% corresponding SCCs. The only aspect of a transition $t$ reflected by
% the formula is its set of marks $\mks(t)$.
Hence, we do not have to distinguish between transitions that are
affiliated to the same SCC and have the same sets of marks.

Let us now fix an SCC $S$. We define an equivalence
${\sim_S}\subseteq\delta_S\times\delta_S$ on transitions % in $\delta_S$
such that $t_1\sim_S t_2$ whenever $\mks(t_1)=\mks(t_2)$.
\begin{lemma} Assume that there is a function $\rem$ and a formula
  $\psi$ such that
  \[
    \textrm{for every set $\emptyset\neq T\subseteq\delta_S$ it holds }
      (T~\msat~\varphi~\iff~\rem(T)~\msat~\psi).\tag{$1$}\label{eq:lem1} 
  \]  
  Then there exists a function $\rem'$ that respects the equivalence
  $\sim_S$ (i.e., it assigns the same marks to equivalent transitions)
  % if $t_1\sim_S t_2$ then $\mks(\rem'(t_1))=\mks(\rem'(t_2))$)
  and
  \[
    \textrm{for every set $\emptyset\neq T\subseteq\delta_S$ it holds }
    (T~\msat~\varphi~\iff~\rem'(T)~\msat~\psi).\tag{$2$}\label{eq:lem2} 
  \]  
\end{lemma}
\begin{proof}
  Let $\rem$ be a function and $\psi$ a formula such that
  \eqref{eq:lem1} holds. To construct the function $\rem'$, we first
  select one transition from each equivalence class of~$\sim_S$. For
  every transition $t=(p,a,M',q)\in\delta_S$, by $\overline{t}$ we
  denote the selected transition equivalent to $t$ and we define the
  function $\rem'$ such that
  $\rem'(t)=(p,a,\mks(\rem(\overline{t})),q)$. Note that we do not need
  to discuss the value of $\rem'$ on transitions outside $\delta_S$ as
  it is not relevant for the lemma. Clearly, $\rem'$ respects the
  equivalence $\sim_S$. It remains to show that \eqref{eq:lem2} holds
  for $\rem'$ and $\psi$.

  Let $T\subseteq\delta_S$ be a % an arbitrary
  nonempty set. We construct
  the set $\overline{T}=\{\overline{t}\mid t\in T\}$. As
  $\mks(t)=\mks(\overline{t})$ for all transitions of $\delta_S$, we
  get $\mks(T)=\mks(\overline{T})$ and thus
  \[
    T~\msat~\varphi~\iff~\overline{T}~\msat~\varphi.
  \]
  Now we apply $\eqref{eq:lem1}$ to $\overline{T}$ and we get % that
  \[
    \overline{T}~\msat~\varphi~\iff~\rem(\overline{T})~\msat~\psi.
  \]
  Finally, the definition of $\rem'$ implies that
  $\rem'(T)=\rem(\overline{T})$ and thus
  \[
    \rem(\overline{T})~\msat~\psi~\iff~\rem'(T)~\msat~\psi.
  \]
  Altogether, we obtain
  % \[
  %   \setlength{\arraycolsep}{0pt}
  %   \begin{array}{rl}
  %     T~\msat~\varphi~ 
  %     & \iff~\overline{T}~\msat~\varphi \\
  %     & \iff~\rem(\overline{T})~\msat~\psi\\
  %     & \iff~\rem'(T)~\msat~\psi
  %   \end{array}
  % \]
  \[
      T~\msat~\varphi~ 
      \iff~\overline{T}~\msat~\varphi
      \iff~\rem(\overline{T})~\msat~\psi
      \iff~\rem'(T)~\msat~\psi
  \]  
  which proves that \eqref{eq:lem2} holds for $\rem'$ and $\psi$.%\qed
\end{proof}

The lemma suggests the following simplification of the whole formula
$\Phi_{1,C,K}$ built with $\mcycle_1(\vec{e})$. Before we build the
formula, we compute the equivalences $\sim_S$ for all SCCs and
temporarily remove all transitions affiliated to SCCs except one of
each equivalence class. Then we build the formula $\Phi_{1,C,K}$ for
the pruned automaton. The more transitions we removed, the shorter
formula with less $e_t$ variables we obtain. If the formula
$\Phi_{1,C,K}$ for the pruned automaton is satisfiable, we derive
$\rem$ and $\psi$ from its model and extend % use them
% with the original automaton. We only need to extend
$\rem$ to all transitions of the original automaton such that
it changes the acceptance marks on all equivalent transitions in the
same way. In the following, we use this simplification whenever
$\Phi_{1,C,K}$ is employed.


\subsection{Intermediate version $\mcycle_2(\vec{e})$}
The intermediate version says that $\Te$ is nonempty,
$\Te\subseteq\delta_S$ for some SCC $S$, and for each state $q\in Q$
it holds that $\Te$ contains a transition leading to $q$ if and only
if it contains a transition leaving $q$. Formally,
\[
%  \mcycle_2(\vec{e})=\bigvee_{t\in\delta}e_t~\wedge~
  \mcycle_2(\vec{e})=\mcycle_1(\vec{e})~\wedge~
  \bigwedge_{q\in Q}\Big(\bigvee_{t'\in\delta~\cap~Q\times\Sigma\times 2^M\times\{q\}}\hspace{-1cm}e_{t'}\hspace{1cm}\iff
  \bigvee_{t''\in\delta~\cap~\{q\}\times\Sigma\times 2^M\times Q}\hspace{-1cm}e_{t''}\hspace{6mm}\Big).
\]
This condition is satisfied by every cycle, but also by some sets of
transitions that are not cycles. Some examples of such sets are provided in Figure~\ref{fig:inter}.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=90,xshift=-4.5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] (p)
      (p) edge[out=30,in=150] (q)
      (q) edge[out=30,in=-30,looseness=10] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}

    \begin{scope}[initial angle=90,densely dotted,black!35]
      \node[state,initial,solid,draw=black] (p) at (0,0) {};
      \node[state,solid,draw=black] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10,black,solid] (p)
      (p) edge[out=30,in=150,black,solid] (q)
      (q) edge[out=30,in=-30,looseness=10,black,solid] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}

    \begin{scope}[initial angle=90,densely dotted,black!35,xshift=4.5cm]
      \node[state,initial,solid,draw=black] (p) at (0,0) {};
      \node[state,solid,draw=black] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10,black,solid] (p)
      (p) edge[out=30,in=150] (q)
      (q) edge[out=30,in=-30,looseness=10,black,solid] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}
  \end{tikzpicture}
  \caption{An automaton structure % where the transition set forms a cycle
    (left) and two sets $\Te$ (middle and right) that are not
    cycles even if $\mcycle_2(\vec{e})$ holds. The transition labels
    and acceptance marks are not depicted.}
  \label{fig:inter}
\end{figure}

\subsection{Strict version $\mcycle_3(\vec{e})$}
Before we give the definition of $\mcycle_3(\vec{e})$, we prove that
cycles can be characterised in the following way.
\begin{lemma}
  A nonempty set $T\subseteq\delta$ is a cycle if and only if, for each
  set of states $S\subseteq Q$, one of the following conditions holds.
  \begin{enumerate}[A.]
  \item\label{en:1} All transitions in $T$ lead from a state in $S$ to a state in $S$ (i.e., $T\subseteq\delta_S$).
  \item\label{en:2} All transitions in $T$ lead from a state outside $S$ to a state outside $S$ (i.e., $T\subseteq\delta_{Q\smallsetminus S}$).
  \item\label{en:3} $T$ contains a transition leading from a state in $S$ to a state outside $S$ and a transition leading from a state outside
    $S$ to a state in $S$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We first prove the direction ``$\Longrightarrow$''. Let $T$ be a
  cycle and $S\subseteq Q$ be an arbitrary set of states. We show that
  if (\ref{en:1}) and (\ref{en:2}) do not hold, then (\ref{en:3}) has
  to hold. Hence, assume that $T\not\subseteq\delta_S$ and
  $T\not\subseteq\delta_{Q\smallsetminus S}$. Then there are two
  cases.
  \begin{itemize}
  \item $T$ contains a transition $t\in\delta_S$ and a transition
    $t'\in\delta_{Q\smallsetminus S}$. The definition of a cycle
    implies that there exists a path $t_1t_2\ldots t_n\in T^+$ from a
    state $p$ back to $p$ containing both $t$ and $t'$. However, this
    implies that $T$ contains a transition leading from a state in $S$
    to a state outside $S$ and a transition leading from a state outside $S$
    to a state in $S$.
  \item $T$ contains a transition $t$ leading from a state in $S$ to a
    state outside $S$ (or vice versa). However, as $T$ is a cycle,
    there exists a path $t_1t_2\ldots t_n\in T^+$ that leads from a
    state $p$ to the same state and contains $t$. Hence, $T$ has to
    contain also a transition leading from a state outside $S$ to a
    state in $S$ (or vice versa).
  \end{itemize}
  In both cases, (\ref{en:3}) holds.

  Now we prove the opposite direction ``$\Longleftarrow$'' by
  contraposition. Assume that a nonempty set $T$ is not a cycle. We
  show that there is a set $S\subseteq Q$ such that neither
  (\ref{en:1}) nor (\ref{en:2}) nor (\ref{en:3}) holds. Let $p$ be a
  state such that some transition of $T$ leads from $p$. We define the
  set $\post$ of states reachable from $p$ via transitions in $T$ and the set
  $\pre$ of states from which $p$ is reachable via transitions of $T$.
  \[
    \begin{array}{r}
    \post=\{p\}\cup\{q\in Q\mid \textrm{there is a path in }T^+\textrm{ from }p\textrm{ to }q\}\\[.5ex]
    \pre=\{p\}\cup\{q\in Q\mid \textrm{there is a path in }T^+\textrm{ from }q\textrm{ to }p\}
    \end{array}
  \]  
  As there is a transition of $T$ leading from $p$, we have that
  $T\not\subseteq\delta_{Q\smallsetminus\post}$ and
  $T\not\subseteq\delta_{Q\smallsetminus\pre}$, i.e., (\ref{en:2})
  does not hold for $\post$ and $\pre$. Further, the definition of
  $\post$ implies that there is no transition of $T$ leading from a
  state in $\post$ to a state outside $\post$, which means that
  (\ref{en:3}) does not hold for $\post$. Similarly, $T$ contains no
  transition leading from a state outside $\pre$ to a state in $\pre$,
  which means that (\ref{en:3}) does not hold for $\pre$. Now we prove
  by contradiction that (\ref{en:1}) does not hold for at least one of
  $\post,\pre$. Hence, let us assume that $T\subseteq\delta_\post$ and
  $T\subseteq\delta_\pre$. Then for each $t_i\in T$ leading from $p_i$
  to $q_i$ we have that $p_i\in\post$ and $q_i\in\pre$, which implies
  that
  \begin{itemize}
  \item $p_i=p$ (we set $\rho'_i=\varepsilon$ in this case) or
    there is a path $\rho'_i\in T^+$ leading from $p$ to $p_i$, and
  \item $q_i=p$ (we set $\rho''_i=\varepsilon$ in this case) or
    there is a path $\rho''_i\in T^+$ leading from $q_i$ to $p$.
  \end{itemize}
  Then there is a path $\rho_i=\rho'_it_i\rho''_i\in T^+$ leading from
  $p$ back to $p$ and containing $t_i$. If we concatenate all these
  paths, we get the path $\rho_1\rho_2\ldots\rho_{|T|}\in T^+$ that
  contains all transitions of $T$ and leads from $p$ back to $p$,
  which means that $T$ is a cycle.  This is a contradiction.%\qed
\end{proof}

The formula $\mcycle_3(\vec{e})$ says that $\Te$ is nonempty and each
set $S\subseteq Q$ satisfies (\ref{en:1}) or (\ref{en:2}) or
(\ref{en:3}).  For each state $q\in Q$, variable $s_q$ says whether
$q$ is in the current set $S$ or not.
\[s_q=\left\{
    \begin{array}{ll}
      1~~ & \textrm{if }q\in S\\[.5ex]
      0 & \textrm{otherwise}    
    \end{array}\right.
\]
By $\vec{s}$ we denote the vectors of all variables of the form $s_q$.
The formula $\mcycle_3(\vec{e})$ is defined as follows.
\begin{align*}
  \mcycle_3(\vec{e})
  &=\bigvee_{t\in\delta}e_t~\wedge~\forall\vec{s}~.~\zeta_{\ref{en:1}}(\vec{e},\vec{s})\,\vee\,
    \zeta_{\ref{en:2}}(\vec{e},\vec{s})\,\vee\,
    \zeta_{\ref{en:3}}(\vec{e},\vec{s})\\ %\qquad\textrm{where}\\
  \zeta_{\ref{en:1}}(\vec{e},\vec{s}) &= \bigwedge_{t=(p,a,M',q)\in\delta}\hspace{-5mm}\big(e_t\implies (s_p\wedge s_q)\big)\\
  \zeta_{\ref{en:2}}(\vec{e},\vec{s}) &= \bigwedge_{t=(p,a,M',q)\in\delta}\hspace{-5mm}\big(e_t\implies (\neg s_p\wedge \neg s_q)\big)\\
  \zeta_{\ref{en:3}}(\vec{e},\vec{s}) &= \big(\bigvee_{t=(p,a,M',q)\in\delta}\hspace{-5mm}e_t\wedge s_p\wedge \neg s_q\big) ~\wedge~
  \big(\bigvee_{t=(p,a,M',q)\in\delta}\hspace{-5mm}e_t\wedge \neg s_p\wedge s_q\big)
\end{align*}

\subsection{Complexity of formulas}
The constructed formulas $\Phi_{j,C,K}$ for $j\in\{1,2,3\}$ use
$|\delta|$ universally quantified variables $e_t$, $|\delta|\cdot K$
free variables $n_{t,k}$, and $C\cdot K$ free variables $i_{c,k}$ and
$f_{c,k}$. The formula $\Phi_{3,C,K}$ additionally uses $|Q|$
variables $s_q$ that are existentially quantified (when the formula is
transformed to prenex normal form) in the scope of universal
quantification of variables $e_t$.

To analyze the length of the formulas, we start with its subformulas.
One can easily check that
$|\msat_\varphi(\vec{e})|\in\bigO(|\varphi|\cdot|\delta|)$ and
$|\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})|\in\bigO(C\cdot
K\cdot|\delta|)$. Further,
$|\mcycle_1(\vec{e})|,|\mcycle_2(\vec{e})|\in\bigO(S\cdot|\delta|)$, % and
%$|\mcycle_2(\vec{e})|\in\bigO(S\cdot|\delta|+|\delta|)=\bigO(S\cdot|\delta|)$,
where $S$ is the number of SCCs in the automaton.  Next,
$|\mcycle_3(\vec{e})|\in\bigO(|\delta|+|Q|)$, which can be simplified
to $|\mcycle_3(\vec{e})|\in\bigO(|\delta|)$ as $|Q|\le|\delta|$
follows from the assumptions that all states are reachable and each
automaton has at least one SCC. Altogether, we get
$|\Phi_{1,C,K}|,|\Phi_{2,C,K}|\in\bigO(S\cdot|\delta|+|\varphi|\cdot|\delta|+C\cdot
K\cdot|\delta|)=\bigO\big((S+|\varphi|+C\cdot K)\cdot|\delta|\big)$
and
$|\Phi_{3,C,K}|\in\bigO(|\delta|+|\varphi|\cdot|\delta|+C\cdot
K\cdot|\delta|)=\bigO\big((|\varphi|+C\cdot K)\cdot|\delta|\big)$.
Note that the formula $\Phi_{3,C,K}$ is asymptotically shorter than
$\Phi_{1,C,K}$ and $\Phi_{2,C,K}$, but it contains an additional quantifier
alternation.

\subsection{Optimizations of formulas}
Finally, we mention three simple optimizations of the formula
construction, which are always applied in the rest of the paper.

The first optimization is based on the fact that every cycle is
completely included in the transition set $\delta_S$ of some SCC
$S$. Hence, all transitions $t$ that do not lead between states of the
same SCC can be completely ignored during the formula
construction. The acceptance marks on such a transition $t$ do not
affect the acceptance of any run as $t$ appears at most once on each
run. For these transitions $t$, we can define $\rem(t)$ such that
$\mks(\rem(t))=\emptyset$.

The second optimization is specific for $\Phi_{3,C,K}$. In the
construction of $\mcycle_3(\vec{e})$, we replace the subformula
$\bigvee_{t\in\delta}e_t$ enforcing the nonemptiness of $\Te$ by
$\mcycle_2(\vec{e})$. This modification prolongs the formula, but it
does not change the overall semantics of $\mcycle_3(\vec{e})$ and our
preliminary experiments showed that QBF solvers can often solve the
modified formula $\Phi_{3,C,K}$ faster.

The third optimization extends $\Phi_{j,C,K}$ into the conjunction
\[
   \Phi_{j,C,K}~\wedge \bigwedge_{c\in\{1,2,\ldots,C\}}\bigwedge_{k\in N_K} (\neg
   i_{c,k}\vee\neg f_{c,k}).
\]
The added part says that no cube contains both $\Inf k$ and $\Fin k$
for any $k$. A cube with both $\Inf k$ and $\Fin k$ would be useless
as it cannot be satisfied by any run.

We have also made some experiments with breaking the symmetries in the
formula models. In particular, we have ordered new acceptance marks by
their placements on transitions and we have ordered the cubes by their
content. As the effect of these modifications was inconclusive, we do
not describe it here.

% \todo{Zminit, ze cela formule
%   ma alepson 1 $\Inf$ nebo $\Fin$? Je to tak, Terko?}

% \subsection{SCC-based optimization}

% Now we present an optimized formula construction based on the fact
% that every cycle is completely included in the transition set
% $\delta_S$ of some SCC $S$. Note that we cannot reduce the number of
% acceptance marks in each SCC separately as all SCCs have to share the
% same acceptance formula after the reduction. However, for each SCC we
% can build the formula $\Phi_{C,K}$ separately and then we can put all
% these formulas into one conjunction such that they share the variables
% $\vec{i},\vec{f}$.

% Now we describe the construction of optimized QBF formulas
% $\Phi^\mathit{opt}_{j,C,K}$ formally. Given an automaton
% $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$ and its SCC $S$, by $\mA^S$ we
% denote the automaton corresponding to the part of $\mA$ delimited by
% $S$, i.e., $\mA^S=(S,M,\Sigma,q',\delta_S,\varphi)$ where $q'$ is an
% arbitrary state of $S$. Further, let $\vec{n}_S$ denote the vector of
% variables $n_{t,k}$ where $t\in\delta_S$ and $k\in N_K$. By
% $\Phi^S_{j,C,K}(\vec{n}_S,\vec{i},\vec{f})$ we denote the formula
% $\Phi_{j,C,K}$ constructed for $\mA^S$ as presented above.
% Finally, we define the optimized QBF formula as
% \[
%   \Phi^\mathit{opt}_{j,C,K}(\vec{n}',\vec{i},\vec{f})=\bigwedge_{\textrm{SCC }S}\Phi^S_{j,C,K}(\vec{n}_S,\vec{i},\vec{f})
% \]
% where $\vec{n}'$ is the vector of all varibles contained in vectors
% $\vec{n}_S$ for SCCs $S$.

% One effect of this optimization is that the formula
% $\Phi^\mathit{opt}_{j,C,K}$ contains no variables $n_{t,k}$ %and $e_t$
% for transitions $t$ that do not lead between states of the same SCC.
% The acceptance marks on such a transition $t$ do not affect the
% acceptance of any run as $t$ appears at most once on each run. For
% these transitions $t$, we can define $\rem(t)$ such that
% $\mks(\rem(t))=\emptyset$.

%}}}
%{{{ algorithm

\section{Reduction algorithm}\label{sec:algo}

This section explains how we use the QBF constructed in the
previous section to reduce the number of acceptance marks in TELA.
First, we describe a \emph{single-level} reduction, which
uses only a single kind of QBF. More precisely, we talk about
\emph{level~1}, \emph{level~2}, or \emph{level~3} reduction when
$\Phi_{1,C,K}$, $\Phi_{2,C,K}$, or
$\Phi_{3,C,K}$ is used, respectively.

\begin{algorithm}[t]
  \DontPrintSemicolon
  \SetKwFunction{FextendBackward}{extendBackward}
  \SetKwProg{PI}{Procedure}{}{}
  \PI{$\mathit{SingleLevelReduction}(\mA,j,\mathit{reduceC})$}{
    \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$, $j\in\{1,2,3\}$, $\mathit{reduceC}\in\{\true,\false\}$}
    \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
    \;
  %   \If{$L(\mA)=\emptyset$}{
  % %      \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'=\{(p,a,\emptyset,q)\mid(p,a,M',q)\in\delta\}$
  %       \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all acceptance marks removed
  %     }
    $C_\mA\gets$ the number of cubes in the formula $\varphi$ transformed to~DNF\;
    $K_\mA\gets$ the number of acceptance marks in $\mA$\;
    $C\gets C_\mA$\;
    $K\gets K_\mA$\;
%    \While(\tcp*[f]{reduction of the number of marks}){$K>1~\wedge~\mathit{satisfiable}(\Phi_{j,C,K{-}1})$}{$K\gets K{-}1$}
    \lWhile{$K>1~\wedge~\mathit{satisfiable}(\Phi_{j,C,K{-}1})$}{$K\gets K{-}1$}
    \If{$K=1$}{
      \If(\tcp*[f]{check the condition $\true$}){all cycles in $\mA$ are accepting}{ %$\mathit{satisfiable}(\Phi_{j,1,0})$}{
        \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\true)$ where $\delta'$ is $\delta$ with all marks removed
      }
      \If(\tcp*[f]{check the condition $\false$}){all cycles in $\mA$ are rejecting}{ %$\mathit{satisfiable}(\Phi_{j,0,0})$}{
        \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all marks removed
      }
    }  
    \If(\tcp*[f]{reduction of the number of cubes}){$\mathit{reduceC}$}{
      \lWhile{$C>1~\wedge~\mathit{satisfiable}(\Phi_{j,C-1,K})$}{$C\gets C{-}1$}
    }
    \If{$K<K_\mA~\vee~C<C_\mA$}{
      compute $\rem$ and $\psi$ from a model of $\Phi_{j,C,K}$\;
      \KwRet $(Q,N_K,\Sigma,\rem(\delta),q_I,\psi)$
    }
    \KwRet $\mA$
  }\;
  \caption{The single-level reduction procedure}
  \label{alg:single}
\end{algorithm}

The reduction procedure called $\mathit{SingleLevelReduction}$ is
given in Algorithm~\ref{alg:single}. Besides the reduction of
acceptance marks, the algorithm also reduces the number of cubes in the acceptance formula if the last argument $\mathit{reduceC}$ is set to
$\true$.
% In the first step, the procedure checks whether the input
% automaton represents the empty language and if this is the case, it
% returns the same automaton with acceptance conditon $\false$ and with
% all acceptance marks removed. Otherwise it
The first \textbf{while} loop gradually decreases the number of marks
until $K=1$ is reached or the QBF solver behind the function
$\mathit{satisfiable}(\Phi_{j,C,K{-}1})$ fails to reduce
the number of marks, i.e., it claims unsatisfiability of the formula
or it runs out of resources. If the loop ends with $K=1$, we check
whether an acceptance condition without any mark (i.e., $\true$ or
$\false$) can be used. These checks are based on an inspection of the
automaton rather than on QBF solving. If some of the checks succeeds,
we return the corresponding automaton without any acceptance
mark. Otherwise, if $\mathit{reduceC}$ is set to $\true$ then the
procedure gradually reduces the number of cubes in the second
\textbf{while} loop. Note that the loop never checks for acceptance
condition with 0 cubes as it is equivalent to $\false$ and this case
was treated above. Finally, if the procedure succeeds to reduce the
number of marks or cubes, it constructs the modified
automaton. Otherwise, it returns the original automaton.

The algorithm can be reformulated to use an incremental approach
instead of building a new formula in each iteration of the
\textbf{while} loops. The incremental version of the first
\textbf{while} loop builds the formula
$\Phi=\Phi_{j,C,K{-}1}$ only in the first iteration. In
each subsequent iteration, it extends this formula with a condition
saying that one more mark is not used in the automaton, i.e., the mark
is neither on edges, nor in the acceptance formula. For example, if we
want to say that the mark $k\in N_K$ is not used, we replace $\Phi$ by
\[
  \Phi~\wedge~\bigwedge_{t\in\delta}\neg n_{t,k}~\wedge\bigwedge_{c\in\{1,2,\ldots C\}}(\neg i_{c,k}\wedge\neg f_{c,k}).
\]
The second \textbf{while} loop can be transformed to an incremental
version similarly. The incremental approach benefits from the fact
that some QBF solvers can decide an extended formula faster as they
reuse the information computed when solving the original formula.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=90,xshift=-3.5cm]
      \node (l) at (1,1.3) {automaton $\mA$};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={1}{1}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic[pos=.33] {acc={2}{2}} pic[pos=.67] {acc={3}{3}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={3}{3}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$(\Fin\tacc{1}{1}\wedge\Inf\tacc{2}{2})\vee(\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}\wedge\Inf\tacc{3}{3})$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=3.5cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,1,\true)$}; %{level 1:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={2}{2}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic[pos=.33] {acc={0}{0}} pic[pos=.67] {acc={2}{2}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={1}{1}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}\wedge\Inf\tacc{2}{2}$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=-3.5cm,yshift=-4.1cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,2,\true)$}; %{level 2:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic {acc={0}{0}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={1}{1}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=3.5cm,yshift=-4.1cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,3,\true)$}; %{level 3:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Fin\tacc{0}{0}$};
    \end{scope}
  \end{tikzpicture}
  \smallskip
  
  \caption{An example illustrating the results of the three
    single-level reductions: an input automaton $\mA$ and the automata
    obtained by reducing it with level 1, level 2, and level~3.}
  \label{fig:example}
\end{figure}

Figure~\ref{fig:example} shows a very simple automaton $\mA$ and the
three automata produced by calls of
$\mathit{SingleLevelReduction}(\mA,j,\true)$ for $j\in\{1,2,3\}$. The
figure clearly illustrates that the higher level of reduction we use,
the more acceptance marks can be reduced. On the other side, lower
levels are typically faster. The best results can be often achieved by
combining reductions of all levels. We call this approach
\emph{multi-level} reduction. It is a straightforward sequential
application of the three levels, see Algorithm~\ref{alg:multi}.

\begin{algorithm}[t]
  \DontPrintSemicolon
  \SetKwFunction{FextendBackward}{extendBackward}
  \SetKwProg{PI}{Procedure}{}{}
  \PI{$\mathit{MultiLevelReduction}(\mA,\mathit{reduceC})$}{
    \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$ and $\mathit{reduceC}\in\{\true,\false\}$}
    \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
    \;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,1,\false)$\;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,2,\false)$\;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,3,\mathit{reduceC})$\;
    \KwRet $\mA$
  }\;
  \caption{The multi-level reduction procedure}
  \label{alg:multi}
\end{algorithm}

%}}}
%{{{ implementation

\section{Implementation}\label{sec:implementation}

The presented reduction algorithms have been implemented in a tool
called \telatko. It is implemented in Python 3 and uses the Spot
library~\cite{duret.16.atva2} for automata parsing and manipulation,
and the theorem prover Z3~\cite{demoura.08.tacas} to solve the
satisfiability of QBF transformed to prenex (non-CNF) normal form. Our
tool is available at
\begin{center}
\url{https://gitlab.fi.muni.cz/xschwar3/telatko}
\end{center}
under the GNU GPLv3
license. The tool can be executed by the command 
\begin{center}
  \texttt{telatko -F <input.hoa> [-L }$j$\texttt{] [-C] [-I] [-T }$t$\texttt{] [-O <output.hoa>]}
\end{center}
where
\begin{description}
\item[\texttt{-F <input.hoa>}] specifies the file with the input automaton in HOA format~\cite{babiak.15.cav}, 
\item[\texttt{-L }$j$] specifies the reduction level; if omitted, the multi-level reduction is used,
\item[\texttt{-C}] switches on the reduction of the number of cubes
  after the number of marks is reduced (it corresponds to
  $\mathit{reduceC}=\true$ in Algorithms~\ref{alg:single}
  and~\ref{alg:multi}),
\item[\texttt{-I}] switches on the incremental version,
\item[\texttt{-T }$t$] sets the timeout for each QBF query to $t$ seconds (the default value is 50 seconds), 
\item[\texttt{-O <output.hoa>}] specifies the output file; if omitted,
  the produced automaton is sent to \textit{stdout} in the HOA format.
\end{description}

If some call of the function $\mathit{satisfiable}(\Phi_{j,C,K{-}1})$
in the first \textbf{while} loop of Algorithm~\ref{alg:single} does
not return $\true$, then the name of the output automaton (included in
the generated HOA) encodes the reason for it. In the case of a single
level reduction, the name has the form \texttt{L$j$\_$k$\_$X$}, where
$j$ is the considered level, $k=K-1$ is the number of acceptance marks
considered by the formula, $X$ is either \texttt{U} if the formula is
unsatisfiable or \texttt{T} if the solver did not decide within the
time limit. If $X$ is \texttt{T}, a longer timeout may lead to further
reductions. If the multi-level reduction is used, the automaton name
contains the information from all levels. For example, the name
`\texttt{L1\_5\_U L2\_3\_U L3\_1\_T}' means that level 1 reduced the
number of marks to 6 (reduction to 5 is impossible on this level),
level 2 reduced it to 4, and level 3 to 2 as the QBF solver did not
finish in the time limit when trying to reduce the number of marks to
1.

%}}}
%{{{ experimental evaluation 

\section{Experimental evaluation}\label{sec:experiments}

To evaluate our reduction technique, we applied \telatko to automata
produced by the following process. We started with two sets of LTL formulas.
\begin{itemize}
\item One set contains all LTL formulas from \emph{literature} that
  are provided by the tool \texttt{genltl} of the Spot
  library~\cite{duret.16.atva2}~2.10.4. For parameterized formula
  patterns, we consider instances for all combinations of parameter
  values from 1 to 4.
\item The second set consists of 400 random LTL formulas with 4 atomic
  propositions. These formulas were generated by the tool
  \texttt{randltl} of the Spot library.
\end{itemize}
On both these sets, we applied the tool \texttt{ltlfilt} of the Spot
library to simplify the formulas and remove duplicates and formulas
equivalent to $\true$ and $\false$. After these steps, we had 348~LTL
formulas from literature and 335 random formulas.
%
Formulas from both sets have been translated to nondeterministic TELA
by two state-of-the-art translators, namely \texttt{ltl2tgba} (used
with option \texttt{-G} to get generic TELA) from the Spot
library~\cite{duret.16.atva2} and
\texttt{ltl3tela}~\cite{major.19.atva}, and to deterministic TELA by
\texttt{ltl3tela} with option \texttt{-D1} and by two state-of-the-art
translators from the Owl library~\cite{kretinsky.18.atva}, namely
\texttt{ltl2dela} (known as Delag)~\cite{muller.17.gandalf} and
\texttt{ltl2dgra} (known as Rabinizer~4)~\cite{kretinsky.18.cav}. Some
translators failed on some formulas: they usually reached a timeout of
60 seconds or produced an automaton that cannot be parsed by the
Spot library.
% produced by the individual tools contains less than 348 automata as not
% all of the formulas are successfully translated due to a timeout of 60
% seconds.
Further, we have removed automata with 0 or 1 acceptance mark as there
is a little point in reducing these. Table \ref{tab:ltltranslators}
shows the exact versions of the translators. For each translator and
each set of formulas, the table also provides the number of fails, the
number of produced automata with less than two marks, and the number
of automata with at least two marks. The numbers of automata with at
least two marks are typeset in bold as these automata are actually
used for the experimental evaluation of our reduction technique.

\begin{table}[t]
  \caption{Considered translators and the numbers of \emph{fails} and
    successfully constructed automata with \emph{at most 1 mark} and
    with \emph{at least 2 marks} for each translator and set of
    formulas.}
\label{tab:ltltranslators}
\centering
\setlength{\tabcolsep}{5.7pt}
\begin{tabular}{lrrrrrrr}
  \toprule
  && \multicolumn{3}{c}{\!348 formulas from literature\!} & \multicolumn{3}{c}{335 random formulas}\\
  \cmidrule(lr){3-5} \cmidrule(lr){6-8}
  &&& \multicolumn{2}{c}{automata with} && \multicolumn{2}{c}{automata with}\\
  \cmidrule(lr){4-5} \cmidrule(lr){7-8}
  \multicolumn{2}{l}{translator ~~~ (version)$^{\text{web}}$}
  & ~~~~fails & \makecell[r]{at most\\[-1ex] 1 mark} & \makecell[r]{\textbf{at least}\\[-1ex] \textbf{2 marks}}
  & ~~~~fails & \makecell[r]{at most\\[-1ex] 1 mark} & \makecell[r]{\textbf{at least}\\[-1ex] \textbf{2 marks}}\\
  % &&& at most & \textbf{at least} && at most & \textbf{at least}\\[-.8ex]
  % \multicolumn{2}{l}{translator ~~~ (version)$^{\text{web}}$} & ~~~~fails & 1 mark & \!\!\!\!\textbf{2 marks} & ~~~~fails & 1 mark & \!\!\!\!\textbf{2 marks}\\
  \midrule 
  \texttt{ltl2tgba -G} & (2.10.4)\tablefootnote{\url{https://spot.lrde.epita.fr}}
  & 0 & 278 & \textbf{70} & 0 & 320 & \textbf{15}\\
  \texttt{ltl3tela} & (2.2.0)\tablefootnote{\url{https://github.com/jurajmajor/ltl3tela}}
  & 18 & 239 & \textbf{91} & 0 & 286 & \textbf{49}\\
  \texttt{ltl3tela -D1} & (2.2.0)\footnotemark[2]
  & 20 & 247 & \textbf{81} & 0 & 291 & \textbf{44}\\ 
  \texttt{ltl2dela} & (21.0)\tablefootnote{\label{fn:owl}\url{https://owl.model.in.tum.de/}}
  & 5 & 214 & \textbf{129} & 0 & 246 & \textbf{89}\\
  \texttt{ltl2dgra} & (21.0)\footnotemark[3]
  & 12 & 102 & \textbf{234} & 0 & 130 & \textbf{205}\\
  \bottomrule
\end{tabular}
\end{table}

To all automata,
% To each automata set (that is, the automata with at least two marks
% produced by an individual LTL translator for one of the two formula
% sets),
we have applied all single-level reductions and the multi-level
reduction, always with incremental approach and without reducing the
number of cubes. We do not reduce the number of cubes as our primary
aim is to reduce the number of acceptance marks.
%\todo{Vysvetlit, proc neredukujeme pocet cubes?}
The timeout for each QBF query was set to 30 seconds.
%
All reductions have been performed by the tool \texttt{telatko}
built with Spot library version 2.10.4 and Z3 version 4.8.15. The
experiments have been run on a computer with Intel$^\text{®}$ Core™ i7-8700
processor and 32~GB of memory running Ubuntu 20.04.4. We used the tool
\texttt{autcross} of the Spot library to get the statistics of the
reduced automata and the running times.

\begin{table}[tp]
  \caption{For each automata set identified by the translator and the
    set of formulas, the table provides the cumulative number of
    acceptance marks before any reduction (in the box), after
    reduction of individual levels and after multi-level reduction
    (column \emph{marks}). The column \emph{reduction} shows the
    percentage of saved acceptance marks and \emph{time} reports the
    cumulative reduction time in seconds. The column \textit{solver
      timeout} indicates the number of instances where the last call
    to the QBF solver timed out.  }
\label{tab:cumm-data}
\centering
\setlength{\tabcolsep}{3.7pt}
\newcommand{\mybox}[1]{\fbox{\begin{minipage}{4.7cm}\centering#1\end{minipage}}}
\begin{tabular}{lcrrrrrrrr}
  \toprule
  && \multicolumn{4}{c}{\makecell{reduction of marks in automata\\[-.8ex] from formulas from literature}}
  & \multicolumn{4}{c}{\makecell{reduction of marks in automata\\[-.8ex] from random formulas}}
  \\ \cmidrule(lr){3-6} \cmidrule(lr){7-10}
  translator & \makecell{reduction\\[-1ex] level}
  & marks & \makecell{reduction\\[-1ex] [\%]} & \makecell{time\\[-1ex] [s]} & \makecell{solver\\[-1ex] timeout} 
  & marks & \makecell{reduction\\[-1ex] [\%]} & \makecell{time\\[-1ex] [s]} & \makecell{solver\\[-1ex] timeout} \\
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl2tgba -G}} 
  & \multicolumn{4}{c}{\mybox{198 marks in 70 automata}}
  & \multicolumn{4}{c}{\mybox{32 marks in 15 automata}}\\
  & 1
  & 198 & 0.0~~~ & 48.5 & 0~~~
  &   32 &   0.0~~~ &    8.4 & 0~~~ \\                     
  & 2
  & 198 & 0.0~~~ & 65.2 & 0~~~
  &   31 &   3.1~~~ &    9.4 & 0~~~ \\                     
  & 3
  & 189 & 4.5~~~ & 409.8 & 7~~~
  &   26 &   18.8~~~ &    43.9 & 1~~~ \\                     
  & multi
  & 189 & 4.5~~~ & 427.6 & 7~~~
  &   26 &   18.8~~~ &    44.9 & 1~~~ \\                    
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl3tela}} 
  & \multicolumn{4}{c}{\mybox{348 marks in 91 automata}}
  & \multicolumn{4}{c}{\mybox{120 marks in 49 automata}}\\
  & 1
  & 332 & 4.6~~~ & 530.3 & 13~~~
  &   101 &   15.8~~~ &     32.4 &  0~~~ \\                     
  & 2
  & 334 & 4.0~~~ & 551.0 & 14~~~
  &   100 &   16.7~~~ &     32.3 &  0~~~ \\                     
  & 3
  & 326 & 6.3~~~ & 698.5 & 18~~~
  &   95 &   20.8~~~ &     66.9 &  1~~~ \\                     
  & multi
  & 319 & 8.3~~~ & 1619.2 & 18~~~
  &   95 &   20.8~~~ &    73.4 & 1~~~ \\                    
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl3tela -D1}} 
  & \multicolumn{4}{c}{\mybox{272 marks in 81 automata}}
  & \multicolumn{4}{c}{\mybox{97 marks in 44 automata}}\\
  & 1
  & 272 & 0.0~~~ & 383.1 & 9~~~
  &   95 &   2.1~~~ &     23.8 &  0~~~ \\                     
  & 2
  & 272 & 0.0~~~ & 386.6 & 10~~~
  &   95 &   2.1~~~ &     24.6 &  0~~~ \\                     
  & 3
  & 272 & 0.0~~~ & 950.2 & 14~~~
  &   92 &   5.2~~~ &     54.1 &  0~~~ \\                     
  & multi
  & 272 & 0.0~~~ & 1659.6 & 16~~~
  &   92 &   5.2~~~ &    67.2 & 1~~~ \\                    
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl2dela}} 
  & \multicolumn{4}{c}{\mybox{523 marks in 129 automata}}
  & \multicolumn{4}{c}{\mybox{234 marks in 89 automata}}\\
  & 1
  & 386 & 26.2~~~ & 811.4 & 18~~~
  &   154 &   34.2~~~ &     89.0 &  0~~~ \\                     
  & 2
  & 391 & 25.2~~~ & 1071.6 & 19~~~
  &   153 &   34.6~~~ &     123.6 &  0~~~ \\                     
  & 3
  & 397 & 24.1~~~ & 7326.8 & 26~~~
  &   149 &   36.3~~~ &     172.7 &  2~~~ \\                     
  & multi
  & 378 & 27.7~~~ & 9186.0 & 24~~~
  &   148 &   36.8~~~ &    219.8 & 2~~~ \\
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl2dgra}} 
  & \multicolumn{4}{c}{\mybox{882 marks in 234 automata}}
  & \multicolumn{4}{c}{\mybox{491 marks in 205 automata}}\\
  & 1
  & 544 & 38.3~~~ & 859.1 & 14~~~
  &   293 &   40.3~~~ &     275.6 &  0~~~ \\                     
  & 2
  & 554 & 37.2~~~ & 1073.5 & 17~~~
  &   280 &   43.0~~~ &     283.9 &  0~~~ \\                     
  & 3
  & 553 & 37.3~~~ & 1349.7 & 22~~~
  &   267 &   45.6~~~ &     433.6 &  3~~~ \\                     
  & multi
  & 535 & 39.3~~~ & 2434.0 & 23~~~
  &   264 &   46.2~~~ &    411.7 & 2~~~ \\                             
  \bottomrule                                                                     
\end{tabular}
\end{table}

For each automata set identified by the translator and the set of
formulas, Table~\ref{tab:cumm-data} shows the cumulative numbers of
marks in the input automata set and after each reduction, together
with the reduction ratio and total time spent by the considered
reduction. The column \textit{solver timeout} shows the number of
automata for which the last query to QBF solver did not finish within
the 30~seconds limit. The timeout of the last QBF query means that the
automaton may be potentially further reduced if a longer time limit is
used. One can observe that a higher level sometimes achieves a smaller
reduction than a lower level (e.g., compare level~1 and level~2 for
\texttt{ltl3tela} on automata coming from formulas from
literature). This is caused by the QBF solver timeouts occurring
earlier as formulas constructed by the higher level are more
complex. The automata sets produced by \texttt{ltl2dela} and
\texttt{ltl2dgra} on formulas from literature do not contain any
automaton where level~2 or level~3 achieves a better result than
level~1. However, all levels contribute to the reductions in the
multi-level setting.

Table~\ref{tab:heatmap} shows the number of all automata constructed
from formulas from literature that have a given number of original
acceptance marks and a given number of acceptance marks after
multi-level reduction. The table indicates that in many cases only 1
or 2~marks can be saved. However, the achieved reduction is
substantial for some automata with a higher number of original
acceptance marks. For example, in 26 cases, we have reduced 7 or more
acceptance marks to only 4 or less.
% Moreover, there were many timeouts of the last QBF query for manof these automata.
% Let us note that some that some reductions are the results are promising, e.g. in 17 cases, we have successfully
% reduced 8 or more acceptance marks to only 4.
Table~\ref{tab:heatmap-random} shows the same information for all
automata constructed from random formulas.

\begin{table}[t]
  \caption{The effect of multi-level reduction on automata constructed
    from formulas from literature.  A cell on coordinates $(x,y)$
    contains the number of automata that have been reduced from $x$ to
    $y$ acceptance marks. If the cell contains a sum of two numbers,
    the latter represents the number of automata where the attempt to
    reduce another mark has been unsuccessful due to a QBF solver
    timeout.}
\label{tab:heatmap}
\setlength{\tabcolsep}{2.5pt}
\centering
\input{table-heatmap.tex}
\end{table}

\begin{table}[t]
\caption{The effect of multi-level reduction on automata constructed
    from random formulas. The meaning of each cell is the same as in Table~\ref{tab:heatmap}.}
\label{tab:heatmap-random}
\setlength{\tabcolsep}{2.5pt}
\centering
\input{table-heatmap-random.tex}
\end{table}

\begin{figure}[p]
  \centering
  \input{quantile.tex}
  \bigskip\bigskip
  \input{quantile-random.tex}
  \bigskip
  \caption{Running times of \telatko on individual automata of each automata set.
    Automata sets constructed from formulas from literature are in the upper graph,
    automata sets constructed from random formulas are in the lower graph.
    Each line shows the time ($y$ axis) needed by \telatko to process the
    $x^\textrm{th}$ automaton of the set, where automata in the set are ordered by
    their processing time.
    % The $x$ axis represents the number of automata from each automata
    % set that are processed by \telatko in the time shown on the $y$
    % axis.
  }
\label{fig:quantile}\end{figure}

Figure~\ref{fig:quantile} presents the time spent by multi-level
reduction on individual automata of each automata set. The charts
show a pleasing finding that for every set, most automata are reduced
in under 5 seconds and the high cumulative running times are caused by 
a relatively small number of complicated automata.

%}}}
%{{{ conclusion

\section{Conclusions}\label{sec:conclusion}

We have presented a method reducing the number of acceptance marks in
transition-based Emerson-Lei automata with use of QBF solving and
without altering automata structure. We have implemented the method in
a tool called \texttt{telatko}. The current applications of the tool
are twofold. First, it can reduce the number of acceptance marks of a
given TELA. Second, it discloses how tools producing TELA are
economical with acceptance marks. The presented experimental results
show that the tool can indeed reduce the number of acceptance marks in
automata produced by all considered state-of-the-art LTL to automata
translators. Further, it clearly shows that the translators of the Owl
library are significantly less economical with acceptance marks than
the other two translators.

The reduction of acceptance marks is not the only application of the
presented approach. For example, it can be easily adapted to look for
an equivalent automaton with the same structure and an acceptance
formula of a specific form (e.g., without any $\Fin m$ atoms). Even
though the QBF queries can be time-consuming, in practice one can
often find a good trade-off between speed and efficiency by adjusting 
the formula precision and choosing a reasonable timeout.

% In the future, we plan to improve the reduction process (e.g., use the
% bisection method to reduce the number of acceptance marks more
% efficiently) and study whether the reduction of acceptance condition
% can enable further reductions or simplifications of automata
% structures.

%}}}

% \section{TODO}

% \noindent
% Do budoucna:
% \begin{itemize}
% \item level 1 bez SCC optimalizace
% \item nahradit weak SCC jednou hranou pro neakceptujici a jinou pro akceptujici
% \item sladit konstrukci QBF formuli s implementaci
% \item podivat se znovu na uzitecnost a potrebnost optimalizaci typu ``klauzule neni false'' a ``alespon jedna klauzule je neprazdna''
% \item sladit popis algoritmu s implementaci
% \item v experimentech nejak sledovat vztah usetreneho casu a usetrenych znacek?
% \item zkusit aplikovat na jine typy automatu (treba TGBA nebo Rabin)?
% \item zkusit, zda/jak redukce znacek umozni redukovat stavovy prostor
% \end{itemize}

%\bibliographystyle{abbrvnat}
\bibliography{mc}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% End:
