% vim: tw=78 ai spell spelllang=en

\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}

\bibliographystyle{plainurl}% the mandatory bibstyle

\usepackage{multirow}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{makecell}
\usepackage[table]{xcolor}
%\usepackage{arydshln}
%\newcommand\VRule[1][\arrayrulewidth]{\vrule width #1}
\usepackage[noend]{algorithm2e}
\usepackage{amsmath,amssymb}
\usepackage{enumerate}
\usepackage{tablefootnote}

\usepackage{tikz}
% TikZ libraries
\usetikzlibrary{myautomata}
\usetikzlibrary{fit, backgrounds}
\usetikzlibrary{extshapes}

\usepackage{pgfplots}
\pgfplotsset{compat=newest}

%{{{ (La)TeX definitions

\newcommand{\Nset}{{\mathbb{N}_0}}
\newcommand{\todo}[1]{\marginpar{\textcolor{red}{#1}}}
\newcommand{\fixme}[1]{\textcolor{red}{#1}}
%\newcommand{\todo}[1]{}
%\def\Inf{\ensuremath{\mathsf{Inf}}}
%\def\Fin{\ensuremath{\mathsf{Fin}}}
\DeclareMathOperator{\Inf}{\mathsf{Inf}}
\DeclareMathOperator{\Fin}{\mathsf{Fin}}
\newcommand{\minf}{\mathit{inf}}
\newcommand{\mks}{\mathit{mks}}
%\newcommand{\oM}{\widehat{M}}
\newcommand{\oM}{N}
\newcommand{\rem}{\mathit{nm}}
\newcommand{\mcycle}{\mathit{cycle}}
\newcommand{\msat}{\mathit{satisfies}}
\newcommand{\Te}{T_{\vec{e}}}
% \newcommand{\pre}{{\leftarrow\!\!S}}
% \newcommand{\post}{{S\!\!\rightarrow}}
\newcommand{\pre}{{S_\mathit{pre}}}
\newcommand{\post}{{S_\mathit{post}}}
\def\false{\mathit{false}}
\def\true{\mathit{true}}
\newcommand{\mA}{\mathcal{A}}
\newcommand{\mB}{\mathcal{B}}
\newcommand{\bigO}{\mathcal{O}}

\newcommand{\telatko}{\texttt{telatko}\xspace}

% setting the color of comments in algorithm
\definecolor{algoColorComment}{RGB}{204, 51, 0}
\definecolor{algoColorComment2}{RGB}{204, 153, 102}
\newcommand{\decmt}[1]{{\color{algoColorComment2}\texttt{#1}}}
\SetCommentSty{decmt}

%}}}
%{{{ hyperref and ORCID ref

% \makeatletter
% \RequirePackage[bookmarks,unicode,colorlinks=true]{hyperref}%
%    \def\@citecolor{blue}%
%    \def\@urlcolor{blue}%
%    \def\@linkcolor{blue}%
% \def\UrlFont{\rmfamily}
% \def\orcidID#1{\smash{\href{http://orcid.org/#1}{\protect\raisebox{-1.25pt}{\protect\includegraphics{orcid_color.eps}}}}}
% \makeatother

% \usepackage{academicons}
% \definecolor{orcidlogocol}{HTML}{A6CE39}

%}}}

%{{{ title and authors

\title{Reducing Acceptance Marks in Emerson-Lei Automata by QBF Solving}
\author{Tereza Schwarzov\'{a}}{%Faculty of Informatics,
  Masaryk University, Brno, Czech Republic}{xschwar3@mail.muni.cz}{https://orcid.org/0009-0001-9016-5399}{}
\author{Jan Strej\v{c}ek}{%Faculty of Informatics,
  Masaryk University, Brno, Czech Republic}{strejcek@fi.muni.cz}{https://orcid.org/0000-0001-5873-403X}{}
\author{Juraj Major}{%Faculty of Informatics,
  Masaryk University, Brno, Czech Republic}{major@fi.muni.cz}{https://orcid.org/0009-0007-1871-9047}{}
\authorrunning{T. Schwarzov\'{a}, J. Strej\v{c}ek, and J. Major}
\Copyright{Tereza Schwarzov\'{a}, Jan Strej\v{c}ek, and Juraj Major}
\ccsdesc[500]{Theory of computation~Logic}
\ccsdesc[500]{Theory of computation~Automata over infinite objects}
\keywords{Emerson-Lei automata, TELA, automata reduction, QBF, telatko}
\funding{T.~Schwarzová received funding from
the European Union’s Horizon Europe program under the Grant Agreement
No.\ 101087529.}

%}}}

\begin{document}

\maketitle

%{{{ abstract

\begin{abstract}
  This paper presents a novel application of QBF solving to automata
  reduction. We focus on \emph{Transition-based Emerson-Lei automata
    (TELA)}, which is a popular formalism that generalizes many
  traditional kinds of automata over infinite words including Büchi,
  co-Büchi, Rabin, Streett, and parity automata. Transitions in a TELA
  are labelled with acceptance marks and its accepting formula is a
  positive Boolean combination of atoms saying that a particular mark
  has to be visited infinitely or finitely
  often. % in an accepting run.
  Algorithms processing these automata are often very sensitive to the
  number of %different
  acceptance marks. We introduce a new technique for reducing the
  number of %different
  acceptance marks in TELA based on satisfiability of \emph{quantified
    Boolean formulas (QBF)}.
  % : if a constructed QBF formula is satisfiable then
  % its model encodes an equivalent accepting formula with less
  % acceptance marks.
  %
  % In fact, we present three formula constructions
  % % trading speed for higher reduction efficiency.
  % with increasing reduction potential and formula complexity, and thus
  % also decreasing speed of their satisfiability solving.
  We evaluated
  our reduction technique on TELA produced by state-of-the-art tools
  of the libraries Owl and Spot and by the tool \texttt{ltl3tela}. The
  technique reduced some acceptance marks in automata produced by all
  the tools. \fixme{On automata with more than one acceptance mark produced
  by tools Delag and Rabinizer~4 of the Owl library, our technique reduced
  29.1\% and 38.5\% of acceptance marks, respectively.}
  % The achieved
  % reduction of acceptance marks on automata produced by tools of the Owl library was
  % between 25 and 40\%.
\end{abstract}

%}}}

%{{{ introduction

\section{Introduction}

% Automata over infinite words (also known as $\omega$-automata) are now
% used in specification, verification, analysis, monitoring, and
% synthesis of various systems with infinite behaviour. The first and
% the most common kind of $\omega$-automata is Büchi
% automaton~\cite{buchi.60.clmps} introduced in 1960. As deterministic
% Büchi automata are less expressive than nondeterministic ones,
% deterministic $\omega$-automata are typically considered with other
% acceptance condition like Rabin, Streett, Muller, or parity. In 1987,
% Emerson and Lei~\cite{emerson.87.scp} introduced $\omega$-automata
% where the acceptance condition can be an arbitrary combination of
% acceptance primitives saying that a certain set of states should be
% visited finitely often or infinitely often. In 2015, the same kind of
% acceptance condition was implemented in the \emph{Hanoi omega-automata
%   format (HOAF)}~\cite{babiak.15.cav}, with the difference that finiteness 

Automata over infinite words like Büchi, Rabin, Streett, or parity
automata play a crucial role in many algorithms related to 
concurrency theory, game theory, and formal methods in general. In
particular, they are used in specification, verification, analysis,
monitoring, and synthesis of various systems with infinite
behaviour. In 1987, Emerson and Lei~\cite{emerson.87.scp} introduced
automata over infinite words where acceptance conditions are arbitrary
combinations of acceptance primitives saying that a certain set of
states should be visited finitely often or infinitely often. In 2015,
the same kind of acceptance condition was described in the \emph{Hanoi
  omega-automata format (HOAF)}~\cite{babiak.15.cav}. The only
difference is that the acceptance primitives talk about finitely or
infinitely often visited acceptance marks rather than sets of states.
Acceptance marks are placed on transitions and each mark identifies
the set of transitions containing this mark. Hence, these automata are
called \emph{transition-based Emerson-Lei automata (TELA)} and they
generalize many traditional kinds of automata over infinite words
including Büchi, co-Büchi, Rabin, Streett, and parity automata.

TELA have attracted a lot of attention during the last few
years~\cite{baier.19.atva,major.19.atva,muller.17.gandalf,renkin.20.atva}.
Their popularity comes probably from the fact that these automata can
often use fewer states than equivalent automata with simpler
acceptance conditions. Further, algorithms handling TELA can
automatically handle all automata with traditional acceptance
conditions. TELA can be obtained for example by translating formulas
of \emph{linear temporal logic (LTL)}~\cite{pnueli.77.focs} with tools
\texttt{ltl2dela} (known as Delag)~\cite{muller.17.gandalf} or
\texttt{ltl2dgra} (known as Rabinizer~4)~\cite{kretinsky.18.cav} of
the Owl library, \texttt{ltl2tgba} of the Spot
library~\cite{duret.16.atva2}, or
\texttt{ltl3tela}~\cite{major.19.atva}. There are also algorithms
processing these automata, for example the emptiness
check~\cite{baier.19.atva} or translation of TELA to parity
automata~\cite{renkin.20.atva,casares.22.tacas}.

Algorithms processing TELA are often sensitive to the number of
acceptance marks more than to other parts of the automaton. For
example, the transformation of TELA to parity automata based on
\emph{color appearance record}~\cite{renkin.20.atva} transforms a TELA
with $m$ acceptance marks and $s$ states into a parity automaton with
up to $m!\cdot s$ states. Further, the emptiness-check
algorithm~\cite{baier.19.atva} is exponential in the number of
acceptance marks that appear in acceptance primitives saying that a
mark has to be visited finitely often, while it is only polynomial in
other measures of the input automaton.

The number of acceptance marks can be algorithmically reduced to one
as every TELA can be transformed to an equivalent Büchi automaton
(this can be easily done for example by Spot~\cite{duret.16.atva2}),
but this reduction is paid by dramatic changes of state space: the
number of states can increase exponentially in the number of
acceptance marks and some important structural properties like
determinism can be lost. This motivates our study of a technique
reducing the number of acceptance marks without altering the structure
of the automaton.

Our reduction technique is heavily based on \emph{quantified Boolean
  formulas (QBF)}. For a given TELA and parameters $C,K$, it produces
a QBF which is satisfiable if and only if there exists an
automaton with the same structure, $K$ acceptance marks, an acceptance
formula in disjunctive normal form with $C$ cubes (i.e., conjunction
of literals), and the same set of accepting runs as the original
automaton. The placement of the marks on transitions and the
acceptance formula can be obtained from a model of the
formula. Besides this formula, we describe also the construction of
two simpler formulas whose satisfiability implies the existence of an
automaton with the same structure, $K$ acceptance marks, and the same
set of accepting runs, but not vice versa.

We have implemented our reduction technique in a tool called
\telatko. We show that the tool can reduce acceptance marks in
automata produced by Delag~\cite{muller.17.gandalf},
Rabinizer~4~\cite{kretinsky.18.cav} (both included in the Owl
library), Spot~\cite{duret.16.atva2}, and
\texttt{ltl3tela}~\cite{major.19.atva}.  While the reduction is
relatively modest on TELA produced by \texttt{ltl3tela} and Spot, it
is substantial on automata produced by the tools of the Owl library.

\paragraph*{Related results}
There is a simple technique~\cite{babiak.13.spin} reducing the number
of acceptance marks in \emph{transition-based generalised Büchi
  automata (TGBA)} without changing its structure. We are not aware
of any existing research aimed at simplification of acceptance
formulas of TELA or reduction of the number of its acceptance marks
without increasing the number of states. There exists only a SAT-based
approach that transforms a deterministic TELA to an
equivalent automaton with a given acceptance condition and a given
number of states~\cite{baarir.15.lpar} (if such an automaton
exists). Further, there are some SAT-based approaches aimed to reduce
the number of states of automata over infinite words. More precisely,
there are reductions designed for nondeterministic Büchi
automata~\cite{ehlers.10.spin}, deterministic Büchi
automata~\cite{ehlers.10.sat}, and deterministic generalized Büchi
automata~\cite{baarir.14.forte}. Note that these techniques are
usually very slow and their authors typically suggest to use them only
for specific purposes like looking for cases where some automata
construction can be improved.

Casares, Colcombet, and Fijalkow very recently introduced a structure
called \emph{alternating cycle decomposition
  (ACD)}~\cite{casares.21.icalp} which compactly represents
%the information about
all accepting and non-accepting automata cycles. We
expect that ACD could %potentially
be used to reduce the number of
acceptance marks or to simplify the acceptance condition. However,
such a reduction is not obvious.
%Moreover, the construction of ACD seems to be computationally expensive.

\paragraph*{Structure of the paper} The next section introduces basic
terms used in the paper. Section~\ref{sec:qbf} explains the
construction of the three mentioned quantified Boolean formulas. The
reduction algorithm based on these formulas is presented in
Section~\ref{sec:algo}. Section~\ref{sec:implementation} describes our
tool \telatko implementing the reduction technique.  Experimental
results are shown in Section~\ref{sec:experiments}. Finally,
Section~\ref{sec:conclusion} suggests other applications of our
QBF-based reduction technique and closes the paper.

%}}}
%{{{ preliminaries

\section{Preliminaries}\label{sec:prelim}

In this section we recall the basic terms related to TELA and QBF.

\begin{definition}[TELA]
  A \emph{transition-based Emerson-Lei automaton (TELA)} is a tuple
  $\mA =(Q,M,\Sigma,\delta,q_I,\varphi)$, where
  \begin{itemize}
  \item $Q$ is a finite set of \emph{states},
  \item $M$ is a finite set of \emph{acceptance marks},
  \item $\Sigma$ is a finite \emph{alphabet},
  \item $\delta \subseteq Q \times \Sigma \times 2^{M} \times Q$ is a
    \emph{transition relation},
  \item $q_I\in Q$ is an \emph{initial state}, and
  \item $\varphi$ is the \emph{acceptance condition} constructed
    according to the following abstract syntax equation, where $m$
    ranges over $M$.
    $$\varphi ::= \true \mid \false \mid \Inf m \mid \Fin m \mid \left( \varphi \land \varphi \right) \mid \left( \varphi \lor \varphi \right)$$
\end{itemize}
\end{definition}

A tuple $t=(p,a,M',q)\in\delta$ is the \emph{transition} leading from
state $p$ to state $q$ labelled with $a$ and acceptance marks $M'$.
The set $M'$ is also referred to by $\mks(t)$. For a set of transitions
$T\subseteq\delta$, let $\mks(T)=\bigcup_{t\in T}\mks(t)$ denote the
set of marks that appear on transitions in $T$.
% of various objects:
% \begin{itemize}
% \item for a transition $t=(p,a,M',q)\in\delta$, $\mks(t)$ denotes the set $M'$,
% \item for a set $T\subseteq\delta$ of transitions,
%   $\mks(T)=\bigcup_{t\in T}\mks(t)$ denotes the set of marks that appear on
%   transitions in $T$,
% \item for a run $\pi$, $\mks(\pi)=\mks(\minf(\pi))$ denotes the set of
%   marks that occur in infinitely many transitions of run $\pi$.
% \end{itemize}

A \emph{run} $\pi$ of $\mA$ over an infinite word
$u = u_{0}u_{1}u_{2}\ldots \in \Sigma^{\omega}$ is an infinite sequence
of adjacent transitions
$\pi=(q_0,u_0,M_0,q_1)(q_1,u_1,M_1,q_2)\ldots\in\delta^{\omega}$ where
$q_0=q_I$. Let $\minf(\pi)$ denote the set of transitions that appear
infinitely many times in $\pi$. Run $\pi$ is \emph{accepting} iff
$\minf(\pi)$ satisfies the formula $\varphi$, where a set $T$ of
transitions satisfies $\Inf m$ iff $m\in\mks(T)$ and it satisfies
$\Fin m$ iff $m\not\in\mks(T)$. The \emph{language} of $\mA$ is
the set
$L(\mA)=\{u\in \Sigma^{\omega}\mid\textrm{there is an accepting run of
}\mA\textrm{ over }u\}$. Two automata $\mA,\mB$ are \emph{equivalent}
if $L(\mA)=L(\mB)$.
% such that $\mA$ has
% an accepting run over $u$.

An acceptance formula $\varphi$ is in \emph{disjunctive normal form
  (DNF)} if it is a disjunction of cubes, where each cube is a
conjunction of atoms of the form $\Fin m$ or $\Inf m$.  Each
acceptance formula can be transformed into an equivalent formula
in~DNF. Formula $\false$ corresponds to the disjunction of zero
cubes and formula $\true$ corresponds to the cube with zero atoms.

A \emph{path} from a state $p$ to a state $q$ is a finite sequence of
adjacent transitions of the form
$\rho=(q_0,u_0,M_0,q_1)(q_1,u_1,M_1,q_2)\ldots(q_{n-1},u_{n-1},M_{n-1},q_n)\in\delta^+$
such that $p=q_0$ and $q=q_n$. A nonempty set of states $S\subseteq Q$
is called a nontrivial \emph{strongly connected component (SCC)} if
for each $p,q\in S$ there is a path from $p$ to $q$. An SCC S is
\emph{maximal} if there is no SCC $S'$ satisfying $S\subsetneq S'$. In
the rest of this paper, SCC always refers to a maximal SCC. Given a
set of states $S\subseteq Q$, let $\delta_S=\delta\cap (S\times \Sigma \times 2^M \times S)$
denote the set of all transitions between states in $S$. Further, for
each mark $m\in M$, let $\delta_m=\{t\in\delta\mid m\in
\mks(t)\}$ denote the set of all transitions
marked with $m$.
% \todo{The sets $\delta_m$ are called \emph{acceptance sets}. Given
% an SCC $S$ and a mark $m\in M$, by $\delta_{S,m}$ we denote the set
% $\delta_{S,m}=\delta_S\cap\delta_m$.}
A set of transitions $T\subseteq\delta$ is called a \emph{cycle} if
there exists a path from a state $p$ to the same state containing each
transition of $T$ at least once and no transition outside
$T$. Finally, we assume that each TELA $\mA$ contains only states $q$
that are reachable from the initial state $q_I$ (i.e., $q=q_I$ or
there is a path from $q_I$ to $q$) as states that are not reachable
from $q_I$ can be eliminated without any impact on $L(\mA)$. We also
assume that each TELA has at least one SCC as automata without any SCC
trivially describe an empty language.

In graphical representation, we often use acceptance marks
$\tacc{1}{1},\tacc{2}{2},\ldots\in M$. Further, an edge 
\begin{tikzpicture}[smallautomaton,baseline=-2pt]
  \node[state] (p) at (0,0) {$p$};
  \node[state] (q) at (1.8,0) {$q$};
  \path [->] (p) edge node[above,pos=.5,overlay] {$a$} node[accset,collacc8, pos=0.65] {k} node[accset,collacc4, pos=0.3] {j} (q);
\end{tikzpicture}
denotes the transition $(p,a,\{\tacc{4}{j},\tacc{8}{k}\},q)\in\delta$. 

By choosing an appropriate acceptance condition, one can easily
represent many classical kinds of automata over infinite words. For
example, a Büchi automaton can be represented as a TELA with the
acceptance condition $\varphi = \Inf\tacc{1}{1}$ and the single mark
$\tacc{1}{1}$ placed on all transitions leaving the accepting states
of the Büchi automaton. Further, a Rabin automaton with $k$ acceptance
pairs can be similarly represented as a TELA with acceptance condition
$\varphi = (\Fin\tacc{5}{1} \land \Inf\tacc{3}{1'}) \lor \ldots \lor
(\Fin\tacc{5}{k} \land \Inf\tacc{3}{k'})$ and marks
$M = \{\tacc{5}{1}, \tacc{3}{1'}, \ldots, \tacc{5}{k},
\tacc{3}{k'}\}$.

\bigskip

\emph{Quantified Boolean formulas (QBF)} are Boolean formulas
extended with universal and existential quantification over
propositional variables. We assume that subformulas of the form
$\forall x.\psi$ and $\exists x.\psi$ do not contain another
quantification of variable $x$ inside $\psi$. The semantics of
$\forall x.\psi$ and $\exists x.\psi$ is given by equivalences
\[
  \begin{array}{rcl}
    \forall x.\psi &~\equiv~& \psi[x\rightarrow\true]~\wedge~\psi[x\rightarrow\false]\\
    \exists x.\psi &~\equiv~& \psi[x\rightarrow\true]~\vee~   \psi[x\rightarrow\false]
  \end{array}
\]
where $\psi[x\rightarrow \rho]$ denotes the formula $\psi$ with all
occurrences of $x$ simultaneously replaced by $\rho$. The equivalences
imply that each QBF can be transformed into an equivalent Boolean
formula. However, the size of this Boolean formula can be exponential
in the size of the original QBF. Let $V$ be the set of all
propositional variables. A mapping $\mu:V\rightarrow\{0,1\}$
is a \emph{model} of a QBF $\varphi$ iff it is a satisfying
assignment of an equivalent Boolean formula. A QBF is
\emph{satisfiable} iff it has a model.

% A QBF $\varphi$ is in the \emph{prenex normal form} if it has the form
% $\varphi = Q_{1}x_{1}...Q_{n}x_{n} . \psi$, where
% $Q_1,\ldots,Q_n \in \{\forall, \exists\}$ and $\psi$ is a Boolean
% formula.

%}}}
%{{{ construction of QBF formulas

\section{Construction of quantified Boolean formulas}\label{sec:qbf}

Recall that we aim to reduce the number of acceptance marks in a given
TELA $\mA =(Q,M,\Sigma,\delta,q_I,\varphi)$ without altering its
structure and language. In other words, we look for
\begin{itemize}
\item a set $\oM$ of acceptance marks satisfying $|\oM|<|M|$,
\item an acceptance formula $\psi$ over $\oM$, and 
\item a function
  $\rem:\delta\rightarrow Q \times \Sigma \times 2^{\oM}\times Q$
  assigning new marks to transitions (i.e., for each
  $t=(p,a,M',q)\in\delta$, we assume that $\rem(t)=(p,a,\oM',q)$ for
  some $\oM'\subseteq\oM$)
  %
  such that the automaton $\mB=(Q,\oM,\Sigma,\rem(\delta),q_I,\psi)$
  is equivalent to $\mA$.
\end{itemize}
% To simplify the task, 
% To ensure that the modified automaton is equivalent to the original one,
We will actually look for $\psi$ and $\rem$ such that each run
$\pi=t_0t_1t_2\ldots$ of $\mA$ is accepting if and only if the run
$\rem(t_0)\rem(t_1)\rem(t_2)\ldots$ of $\mB$ is accepting. This
requirement clearly guarantees the equivalence of $\mA$ and $\mB$,
but it is not a necessary condition for the equivalence. Indeed, there
exist automata where relaxing this requirement can lead to a bigger
reduction of acceptance marks (see Figure~\ref{fig:counter}). However,
looking for $\psi$ and $\rem$ that preserve the acceptance of individual
runs makes the problem easier as we can, for example, ignore the
labelling of transitions by the elements of $\Sigma$.
\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=180,xshift=-3.5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=120,in=60,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=-60,in=-120,looseness=10] pic {acc={1}{1}} pic {l=$b$} (p)
      (p) edge[out=30,in=150] pic {l=$a$} (q)
      (q) edge[out=-150,in=-30] pic {l=$b$} (p);

      \node[acclabel] at (1,-1.7)
      {$\Inf\tacc{0}{0}\wedge\Inf\tacc{1}{1}$};
    \end{scope}
    \begin{scope}[initial angle=180,xshift=3.5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=120,in=60,looseness=10] pic {l=$a$} (p)
      (p) edge[out=-60,in=-120,looseness=10] pic {l=$b$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$a$} (q)
      (q) edge[out=-150,in=-30] pic {l=$b$} (p);

      \node[acclabel] at (1,-1.7)
      {$\Inf\tacc{0}{0}$};
    \end{scope}
  \end{tikzpicture}
  \smallskip
  
  \caption{The left automaton accepts the words % $w\in\{a,b\}^\omega$
    that contain infinitely many occurences of both $a$ and $b$. Each
    accepting run of the left automaton has to contain infinitely many
    occurrences of both transitions looping on the initial
    state. Hence, there does not exist any automaton with the same
    accepting runs as the left automaton and less than two acceptance
    marks. The right automaton accepts the same language using one
    acceptance mark and a different set of accepting runs.}
  \label{fig:counter}
\end{figure}

Our reduction method is based on two facts. First, the acceptance of a
run $\pi$ is fully determined by $\minf(\pi)$. Second, each set
$\minf(\pi)$ is a cycle and vice versa.

% Before we We start with a reformulation of our requirement on $\psi$
% and $\rem$.  Recall that a run $\pi$ of $\mA$ is accepting if and
% only iff $\minf(\pi)$ satisfies $\varphi$.  Further, the following
% lemma says that each set $\minf(\pi)$ is a cycle and vice versa.

\begin{lemma}
  A set $T\subseteq\delta$ is a cycle if and only if
  there is a run $\pi$ such that $\minf(\pi)=T$.
\end{lemma}
\begin{proof}
  To prove the direction `$\Longrightarrow$', we assume that $T$ is a
  cycle. The definition says that there exists a path $\tau$ from a
  state $p$ to the same state containing each transition of $T$ at
  least once and no transition outside $T$. As our automata contain
  only reachable states, there exists a path $\rho$ from the initial
  state $q_I$ to $p$ or $p=q_I$ and we set $\rho=\varepsilon$. The
  infinite sequence $\pi=\rho.\tau^\omega$ is a run satisfying
  $\minf(\pi)=T$.

  To prove the direction `$\Longleftarrow$', we consider a run
  $\pi$.  As $\minf(\pi)$ is the set of transitions that appear
  infinitely many times in $\pi$, there has to be a suffix $\pi'$ of
  $\pi$ containing only transitions of $\minf(\pi)$. Let $p$ be the
  first state of $\pi'$. As each transition of $\pi'$ appears
  infinitely many times in $\pi$ and thus also in $\pi'$, there has to
  be a finite prefix $\rho$ of $\pi'$ such that $\rho$ is a path from
  $p$ to $p$ that contains all transitions of $\minf(\pi)$. In other
  words, the set $\minf(\pi)$ is a cycle.
\end{proof}

Hence, our goal can be reformulated as follows. We look for a new
acceptance formula $\psi$ and a function $\rem$ such that for each
cycle $T\subseteq\delta$, it holds that $T$ satisfies $\varphi$ if and
only if $\rem(T)$ satisfies $\psi$. This can be roughly denoted by the
formula
\[
  \forall T\subseteq\delta~.~\mcycle(T)\implies\big(\msat_\varphi(T) ~\iff~ \msat_{\psi}(\rem(T))\big).
\]
In fact, this corresponds to the shape of the QBF we will
construct. As we are looking for $\psi$ and $\rem$ such that the
formula holds, the subformula $\msat_{\psi}(\rem(T))$ contains many
free variables representing possible instances of $\psi$ and
$\rem$. If the formula is satisfiable, then each of its models encodes
a desired instance of $\psi$ and $\rem$. In the following, we assume
that we are looking for a new acceptance formula $\psi$ in DNF. The
choice of DNF is not fundamental, but inherited from our previous
attempt to reduce acceptance formulas. The presented method can be
easily adapted to look for $\psi$ in \emph{conjunctive normal form
  (CNF)} or in a different shape.

Now we describe the construction of the QBF in detail. The
construction is parametrized by two integers $C,K\ge 0$, where $K$ is
the desired number of acceptance marks and $C$ is the number of cubes
of $\psi$. Without loss of generality, we assume that the reduced
automaton will use the acceptance marks $N_K=\{1,2,\ldots,K\}$.
%Further, we consider only subsets $T\subseteq\bigcup_{\textrm{SCC}~S}\delta_S$
We start with a description of Boolean variables used in the
constructed QBF.
\begin{itemize}
\item For each transition $t\in\delta$, variable $e_t$ says whether
  $t$ is in the current set $T$ or not.
  \[e_t=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if }t\in T\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
%  In fact, we consider variables 
\item For each transition $t\in\delta$ and acceptance mark $k\in N_K$,
  variable $n_{t,k}$ says whether $k$ is on the transition
  $\rem(t)$ or not.
  \[n_{t,k}=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if }k\in\mks(\rem(t))\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
\item For each $c\in\{1,2,\ldots,C\}$ and acceptance mark $k\in N_K$,
  variables $i_{c,k}$ and $f_{c,k}$ say whether the $c^\textrm{th}$
  cube of $\psi$ contains atoms $\Inf k$ or $\Fin k$, respectively.
  \[i_{c,k}=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if the $c^\textrm{th}$ cube of $\psi$ contains $\Inf k$}\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]
  \[f_{c,k}=\left\{
      \begin{array}{ll}
        1~~ & \textrm{if the $c^\textrm{th}$ cube of $\psi$ contains $\Fin k$}\\[.5ex]
        0 & \textrm{otherwise}    
      \end{array}\right.
  \]

\end{itemize}
By $\vec{e},\vec{n},\vec{i},\vec{f}$ we denote the vectors of all
variables of the form $e_t$, $n_{t,k}$, $i_{c,k}$, and $f_{c,k}$,
respectively. The constructed QBF have the form
\[
  \Phi_{C,K}(\vec{n},\vec{i},\vec{f})~~=~~\forall \vec{e}~.~\mcycle(\vec{e})\implies\big(\msat_\varphi(\vec{e}) \iff \msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})\big),
\]
where $\forall\vec{e}$ denotes the sequence composed of $\forall e_t$
for all variables $e_t$. Now we define the subformulas
$\msat_\varphi(\vec{e})$,
$\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$, and three versions of
$\mcycle(\vec{e})$.

The subformula $\msat_\varphi(\vec{e})$ says whether $T$ satisfies the
original acceptance formula $\varphi$ and it is derived directly from
$\varphi$. Recall that $T$ satisfies $\Inf m$ iff $m\in\mks(T)$, which
means that $T$ contains some transition with mark $m$. As the
transitions with mark $m$ form the set $\delta_m$, $\Inf m$ can be
expressed by $\bigvee_{t\in\delta_m}e_t$. Similarly, $T$ satisfies
$\Fin m$ iff $m\not\in\mks(T)$, which can be expressed by
$\bigwedge_{t\in\delta_m}\neg e_t$. Hence, $\msat_\varphi(\vec{e})$
arises from $\varphi$ by replacing
\begin{itemize}
\item all atoms of the form $\Inf m$ by $\bigvee_{t\in\delta_m}e_t$ and
\item all atoms of the form $\Fin m$ by $\bigwedge_{t\in\delta_m}\neg e_t$.
\end{itemize}

Next, we construct the subformula
$\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ that evaluates to true
iff $\rem(T)$ satisfies~$\psi$. The subformula reflects the basic
structure of $\psi$. As we assume that $\psi$ is a disjunction of $C$
cubes, we have
\[
  \msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})=\bigvee_{c\in\{1,2,\ldots,C\}}\xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})
\]
where each $\xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ corresponds to
one cube. Recall that the presence of atoms $\Inf k$ and $\Fin k$ in
the $c^\textrm{th}$ cube is given by variables $i_{c,k}$ and
$f_{c,k}$, respectively. $\Inf k$ is satisfied by $\rem(T)$ iff $T$
contains a transition $t$ such that $k\in\mks(\rem(t))$, which can be
expressed as $\bigvee_{t\in\delta}(e_t\wedge n_{t,k})$. Similarly,
$\Fin k$ is satisfied by $\rem(T)$ iff there is no transition $t\in T$
such that $k\in\mks(\rem(t))$, which can be expressed as
$\bigwedge_{t\in\delta}\neg(e_t\wedge n_{t,k})$. Hence, we set
\[
  \xi_{c,K}(\vec{e},\vec{n},\vec{i},\vec{f})=
  \bigwedge_{k\in N_K}\Big(i_{c,k}\implies\bigvee_{t\in\delta}(e_t\wedge n_{t,k})\Big)\wedge\Big(f_{c,k}\implies\bigwedge_{t\in\delta}\neg(e_t\wedge n_{t,k})\Big).
\]

It remains to define the subformula $\mcycle(\vec{e})$. Let $\Te$
denote the set of transitions represented by $\vec{e}$. The original
intended meaning of $\mcycle(\vec{e})$ is
\[
  \mcycle(\vec{e}) \iff \Te\textrm{ is a cycle}.
\]
In fact, only the direction ``$\Longleftarrow$'' is needed for the
correctness of our reduction method. If there are some valuations of
$\vec{e}$ such that $\mcycle(\vec{e})$ holds and $\Te$ is not a cycle,
then we will superfluously require the equivalence
$\msat_\varphi(\vec{e}) \iff
\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})$ on these valuations.
% adds a superfluous constraint on $\psi$ (represented by
% $\vec{i},\vec{f}$) and $\rem$ (represented by $\vec{n}$).
These superfluous constraints can lead to loss of reduction
opportunities, but not to incorrectness. This observation allows us to
trade the precision of $\mcycle(\vec{e})$ for its simplicity.

We define three versions of $\mcycle(\vec{e})$:
\begin{itemize}
\item $\mcycle_1(\vec{e})$ is a lightweight version, which only says
  that $\Te$ is nonempty and $\Te\subseteq\delta_S$ for some SCC $S$.
  Except for SCCs, it does not use the information about the automaton
  structure, but it comes with an interesting simplification of the
  whole formula $\Phi_{C,K}$.
\item $\mcycle_2(\vec{e})$ is an intermediate version. It says that
  $\Te$ is nonempty, $\Te\subseteq\delta_S$ for some SCC $S$, and
  every transition in $\Te$ has % to have
  a preceding and a succeeding transition in $\Te$, which is a
  necessary condition for being a cycle, but not a sufficient one.
\item $\mcycle_3(\vec{e})$ is a strict version saying that $\Te$ is a
  cycle. Unfortunately, it uses additional universally quantified
  variables corresponding to automata states. Transformation of
  $\Phi_{C,K}$ to prenex normal form turns the quantifiers to
  existential ones and the resulting formula thus contains quantifier
  alternation.
\end{itemize}
We write $\Phi_{j,C,K}$ % where $j\in\{1,2,3\}$
when we want to emphasize
that a particular formula $\Phi_{C,K}$ contains the version
$\mcycle_j(\vec{e})$.

\subsection{Lightweight version $\mcycle_1(\vec{e})$}
The lightweight version is defined as
% \[
%   \mcycle_1(\vec{e})=\bigvee_{t\in\delta}e_t
% \]
% which means only that $\Te$ is nonempty.
\[
  \mcycle_1(\vec{e})=\bigvee_{\text{SCC } S}~~\big(\bigvee_{t\in\delta_S}e_t ~~\wedge \bigwedge_{t'\in\delta\smallsetminus\delta_S}\neg e_{t'}\big)
\]
which means only that $\Te$ is nonempty and $\Te\subseteq\delta_S$ for
some SCC $S$.
This condition is satisfied by every cycle.

The formula $\Phi_{1,C,K}$ built with $\mcycle_1(\vec{e})$ says that
for every nonempty set $T\subseteq\delta_S$ where $S$ is an SCC, $T$
satisfies $\varphi$ if and only if $\rem(T)$ satisfies $\psi$. Note
that the only aspects of a transition $t$ reflected by the formula are
its set of marks $\mks(t)$ and its affiliation to an SCC.
% In partcular, it is not affected by its placement inside the
% corresponding SCCs. The only aspect of a transition $t$ reflected by
% the formula is its set of marks $\mks(t)$.
Hence, we do not have to distinguish between transitions that are
affiliated to the same SCC and have the same sets of marks.

Let us now fix an SCC $S$. We define an equivalence
${\sim_S}\subseteq\delta_S\times\delta_S$ on transitions % in $\delta_S$
such that $t_1\sim_S t_2$ whenever $\mks(t_1)=\mks(t_2)$.
\begin{lemma} Assume that there is a function $\rem$ and a formula
  $\psi$ such that
  \[
    \textrm{for every set $\emptyset\neq T\subseteq\delta_S$ it holds }
      (T~\msat~\varphi~\iff~\rem(T)~\msat~\psi).\tag{$1$}\label{eq:lem1} 
  \]  
  Then there exists a function $\rem'$ that respects the equivalence
  $\sim_S$ (i.e., it assigns the same marks to equivalent transitions)
  % if $t_1\sim_S t_2$ then $\mks(\rem'(t_1))=\mks(\rem'(t_2))$)
  and
  \[
    \textrm{for every set $\emptyset\neq T\subseteq\delta_S$ it holds }
    (T~\msat~\varphi~\iff~\rem'(T)~\msat~\psi).\tag{$2$}\label{eq:lem2} 
  \]  
\end{lemma}
\begin{proof}
  Let $\rem$ be a function and $\psi$ a formula such that
  \eqref{eq:lem1} holds. To construct the function $\rem'$, we first
  select one transition from each equivalence class of~$\sim_S$. For
  every transition $t=(p,a,M',q)\in\delta_S$, by $\overline{t}$ we
  denote the selected transition equivalent to $t$ and we define the
  function $\rem'$ such that
  $\rem'(t)=(p,a,\mks(\rem(\overline{t})),q)$. Note that we do not need
  to discuss the value of $\rem'$ on transitions outside $\delta_S$ as
  it is not relevant for the lemma. Clearly, $\rem'$ respects the
  equivalence $\sim_S$. It remains to show that \eqref{eq:lem2} holds
  for $\rem'$ and $\psi$.

  Let $T\subseteq\delta_S$ be a % an arbitrary
  nonempty set. We construct
  the set $\overline{T}=\{\overline{t}\mid t\in T\}$. As
  $\mks(t)=\mks(\overline{t})$ for all transitions of $\delta_S$, we
  get $\mks(T)=\mks(\overline{T})$ and thus
  \[
    T~\msat~\varphi~\iff~\overline{T}~\msat~\varphi.
  \]
  Now we apply $\eqref{eq:lem1}$ to $\overline{T}$ and we get % that
  \[
    \overline{T}~\msat~\varphi~\iff~\rem(\overline{T})~\msat~\psi.
  \]
  Finally, the definition of $\rem'$ implies that
  $\rem'(T)=\rem(\overline{T})$ and thus
  \[
    \rem(\overline{T})~\msat~\psi~\iff~\rem'(T)~\msat~\psi.
  \]
  Altogether, we obtain
  % \[
  %   \setlength{\arraycolsep}{0pt}
  %   \begin{array}{rl}
  %     T~\msat~\varphi~ 
  %     & \iff~\overline{T}~\msat~\varphi \\
  %     & \iff~\rem(\overline{T})~\msat~\psi\\
  %     & \iff~\rem'(T)~\msat~\psi
  %   \end{array}
  % \]
  \[
      T~\msat~\varphi~ 
      \iff~\overline{T}~\msat~\varphi
      \iff~\rem(\overline{T})~\msat~\psi
      \iff~\rem'(T)~\msat~\psi
  \]  
  which proves that \eqref{eq:lem2} holds for $\rem'$ and $\psi$.%\qed
\end{proof}

The lemma suggests the following simplification of the whole formula
$\Phi_{1,C,K}$ built with $\mcycle_1(\vec{e})$. Before we build the
formula, we compute the equivalences $\sim_S$ for all SCCs and
temporarily remove all transitions affiliated to SCCs except one of
each equivalence class. Then we build the formula $\Phi_{1,C,K}$ for
the pruned automaton. The more transitions we removed, the shorter
formula with less $e_t$ variables we obtain. If the formula
$\Phi_{1,C,K}$ for the pruned automaton is satisfiable, we derive
$\rem$ and $\psi$ from its model and extend % use them
% with the original automaton. We only need to extend
$\rem$ to all transitions of the original automaton such that
it changes the acceptance marks on all equivalent transitions in the
same way. In the following, we use this simplification whenever
$\Phi_{1,C,K}$ is employed.


\subsection{Intermediate version $\mcycle_2(\vec{e})$}
The intermediate version says that $\Te$ is nonempty,
$\Te\subseteq\delta_S$ for some SCC $S$, and for each state $q\in Q$
it holds that $\Te$ contains a transition leading to $q$ if and only
if it contains a transition leaving $q$. Formally,
\[
%  \mcycle_2(\vec{e})=\bigvee_{t\in\delta}e_t~\wedge~
  \mcycle_2(\vec{e})=\mcycle_1(\vec{e})~\wedge~
  \bigwedge_{q\in Q}\Big(\bigvee_{t'\in\delta~\cap~Q\times\Sigma\times 2^M\times\{q\}}\hspace{-1cm}e_{t'}\hspace{1cm}\iff
  \bigvee_{t''\in\delta~\cap~\{q\}\times\Sigma\times 2^M\times Q}\hspace{-1cm}e_{t''}\hspace{6mm}\Big).
\]
This condition is satisfied by every cycle, but also by some sets of
transitions that are not cycles. Some examples of such sets are provided in Figure~\ref{fig:inter}.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=90,xshift=-4.5cm]
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] (p)
      (p) edge[out=30,in=150] (q)
      (q) edge[out=30,in=-30,looseness=10] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}

    \begin{scope}[initial angle=90,densely dotted,black!35]
      \node[state,initial,solid,draw=black] (p) at (0,0) {};
      \node[state,solid,draw=black] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10,black,solid] (p)
      (p) edge[out=30,in=150,black,solid] (q)
      (q) edge[out=30,in=-30,looseness=10,black,solid] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}

    \begin{scope}[initial angle=90,densely dotted,black!35,xshift=4.5cm]
      \node[state,initial,solid,draw=black] (p) at (0,0) {};
      \node[state,solid,draw=black] (q) at (1.8,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10,black,solid] (p)
      (p) edge[out=30,in=150] (q)
      (q) edge[out=30,in=-30,looseness=10,black,solid] (q)
      (q) edge[out=-150,in=-30] (p);
    \end{scope}
  \end{tikzpicture}
  \caption{An automaton structure % where the transition set forms a cycle
    (left) and two sets $\Te$ (middle and right) that are not
    cycles even if $\mcycle_2(\vec{e})$ holds. The transition labels
    and acceptance marks are not depicted.}
  \label{fig:inter}
\end{figure}

\subsection{Strict version $\mcycle_3(\vec{e})$}
Before we give the definition of $\mcycle_3(\vec{e})$, we prove that
cycles can be characterised in the following way.
\begin{lemma}
  A nonempty set $T\subseteq\delta$ is a cycle if and only if, for each
  set of states $S\subseteq Q$, one of the following conditions holds.
  \begin{enumerate}[A.]
  \item\label{en:1} All transitions in $T$ lead from a state in $S$ to a state in $S$ (i.e., $T\subseteq\delta_S$).
  \item\label{en:2} All transitions in $T$ lead from a state outside $S$ to a state outside $S$ (i.e., $T\subseteq\delta_{Q\smallsetminus S}$).
  \item\label{en:3} $T$ contains a transition leading from a state in $S$ to a state outside $S$ and a transition leading from a state outside
    $S$ to a state in $S$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We first prove the direction ``$\Longrightarrow$''. Let $T$ be a
  cycle and $S\subseteq Q$ be an arbitrary set of states. We show that
  if (\ref{en:1}) and (\ref{en:2}) do not hold, then (\ref{en:3}) has
  to hold. Hence, assume that $T\not\subseteq\delta_S$ and
  $T\not\subseteq\delta_{Q\smallsetminus S}$. Then there are two
  cases.
  \begin{itemize}
  \item $T$ contains a transition $t\in\delta_S$ and a transition
    $t'\in\delta_{Q\smallsetminus S}$. The definition of a cycle
    implies that there exists a path $t_1t_2\ldots t_n\in T^+$ from a
    state $p$ back to $p$ containing both $t$ and $t'$. However, this
    implies that $T$ contains a transition leading from a state in $S$
    to a state outside $S$ and a transition leading from a state outside $S$
    to a state in $S$.
  \item $T$ contains a transition $t$ leading from a state in $S$ to a
    state outside $S$ (or vice versa). However, as $T$ is a cycle,
    there exists a path $t_1t_2\ldots t_n\in T^+$ that leads from a
    state $p$ to the same state and contains $t$. Hence, $T$ has to
    contain also a transition leading from a state outside $S$ to a
    state in $S$ (or vice versa).
  \end{itemize}
  In both cases, (\ref{en:3}) holds.

  Now we prove the opposite direction ``$\Longleftarrow$'' by
  contraposition. Assume that a nonempty set $T$ is not a cycle. We
  show that there is a set $S\subseteq Q$ such that neither
  (\ref{en:1}) nor (\ref{en:2}) nor (\ref{en:3}) holds. Let $p$ be a
  state such that some transition of $T$ leads from $p$. We define the
  set $\post$ of states reachable from $p$ via transitions in $T$ and the set
  $\pre$ of states from which $p$ is reachable via transitions of $T$.
  \[
    \begin{array}{r}
    \post=\{p\}\cup\{q\in Q\mid \textrm{there is a path in }T^+\textrm{ from }p\textrm{ to }q\}\\[.5ex]
    \pre=\{p\}\cup\{q\in Q\mid \textrm{there is a path in }T^+\textrm{ from }q\textrm{ to }p\}
    \end{array}
  \]  
  As there is a transition of $T$ leading from $p$, we have that
  $T\not\subseteq\delta_{Q\smallsetminus\post}$ and
  $T\not\subseteq\delta_{Q\smallsetminus\pre}$, i.e., (\ref{en:2})
  does not hold for $\post$ and $\pre$. Further, the definition of
  $\post$ implies that there is no transition of $T$ leading from a
  state in $\post$ to a state outside $\post$, which means that
  (\ref{en:3}) does not hold for $\post$. Similarly, $T$ contains no
  transition leading from a state outside $\pre$ to a state in $\pre$,
  which means that (\ref{en:3}) does not hold for $\pre$. Now we prove
  by contradiction that (\ref{en:1}) does not hold for at least one of
  $\post,\pre$. Hence, let us assume that $T\subseteq\delta_\post$ and
  $T\subseteq\delta_\pre$. Then for each $t_i\in T$ leading from $p_i$
  to $q_i$ we have that $p_i\in\post$ and $q_i\in\pre$, which implies
  that
  \begin{itemize}
  \item $p_i=p$ (we set $\rho'_i=\varepsilon$ in this case) or
    there is a path $\rho'_i\in T^+$ leading from $p$ to $p_i$, and
  \item $q_i=p$ (we set $\rho''_i=\varepsilon$ in this case) or
    there is a path $\rho''_i\in T^+$ leading from $q_i$ to $p$.
  \end{itemize}
  Then there is a path $\rho_i=\rho'_it_i\rho''_i\in T^+$ leading from
  $p$ back to $p$ and containing $t_i$. If we concatenate all these
  paths, we get the path $\rho_1\rho_2\ldots\rho_{|T|}\in T^+$ that
  contains all transitions of $T$ and leads from $p$ back to $p$,
  which means that $T$ is a cycle.  This is a contradiction.%\qed
\end{proof}

The formula $\mcycle_3(\vec{e})$ says that $\Te$ is nonempty and each
set $S\subseteq Q$ satisfies (\ref{en:1}) or (\ref{en:2}) or
(\ref{en:3}).  For each state $q\in Q$, variable $s_q$ says whether
$q$ is in the current set $S$ or not.
\[s_q=\left\{
    \begin{array}{ll}
      1~~ & \textrm{if }q\in S\\[.5ex]
      0 & \textrm{otherwise}    
    \end{array}\right.
\]
By $\vec{s}$ we denote the vectors of all variables of the form $s_q$.
The formula $\mcycle_3(\vec{e})$ is defined as follows.
\begin{align*}
  \mcycle_3(\vec{e})
  &=\bigvee_{t\in\delta}e_t~\wedge~\forall\vec{s}~.~\zeta_{\ref{en:1}}(\vec{e},\vec{s})\,\vee\,
    \zeta_{\ref{en:2}}(\vec{e},\vec{s})\,\vee\,
    \zeta_{\ref{en:3}}(\vec{e},\vec{s})\\ %\qquad\textrm{where}\\
  \zeta_{\ref{en:1}}(\vec{e},\vec{s}) &= \bigwedge_{t=(p,a,M',q)\in\delta}\hspace{-5mm}\big(e_t\implies (s_p\wedge s_q)\big)\\
  \zeta_{\ref{en:2}}(\vec{e},\vec{s}) &= \bigwedge_{t=(p,a,M',q)\in\delta}\hspace{-5mm}\big(e_t\implies (\neg s_p\wedge \neg s_q)\big)\\
  \zeta_{\ref{en:3}}(\vec{e},\vec{s}) &= \big(\bigvee_{t=(p,a,M',q)\in\delta}\hspace{-5mm}e_t\wedge s_p\wedge \neg s_q\big) ~\wedge~
  \big(\bigvee_{t=(p,a,M',q)\in\delta}\hspace{-5mm}e_t\wedge \neg s_p\wedge s_q\big)
\end{align*}

\subsection{Complexity of formulas}
The constructed formulas $\Phi_{j,C,K}$ for $j\in\{1,2,3\}$ use
$|\delta|$ universally quantified variables $e_t$, $|\delta|\cdot K$
free variables $n_{t,k}$, and $C\cdot K$ free variables $i_{c,k}$ and
$f_{c,k}$. The formula $\Phi_{3,C,K}$ additionally uses $|Q|$
variables $s_q$ that are existentially quantified (when the formula is
transformed to prenex normal form) in the scope of universal
quantification of variables $e_t$.

To analyze the length of the formulas, we start with its subformulas.
One can easily check that
$|\msat_\varphi(\vec{e})|\in\bigO(|\varphi|\cdot|\delta|)$ and
$|\msat_{C,K}(\vec{e},\vec{n},\vec{i},\vec{f})|\in\bigO(C\cdot
K\cdot|\delta|)$. Further,
$|\mcycle_1(\vec{e})|,|\mcycle_2(\vec{e})|\in\bigO(S\cdot|\delta|)$, % and
%$|\mcycle_2(\vec{e})|\in\bigO(S\cdot|\delta|+|\delta|)=\bigO(S\cdot|\delta|)$,
where $S$ is the number of SCCs in the automaton.  Next,
$|\mcycle_3(\vec{e})|\in\bigO(|\delta|+|Q|)$, which can be simplified
to $|\mcycle_3(\vec{e})|\in\bigO(|\delta|)$ as $|Q|\le|\delta|$
follows from the assumptions that all states are reachable and each
automaton has at least one SCC. Altogether, we get
$|\Phi_{1,C,K}|,|\Phi_{2,C,K}|\in\bigO(S\cdot|\delta|+|\varphi|\cdot|\delta|+C\cdot
K\cdot|\delta|)=\bigO\big((S+|\varphi|+C\cdot K)\cdot|\delta|\big)$
and
$|\Phi_{3,C,K}|\in\bigO(|\delta|+|\varphi|\cdot|\delta|+C\cdot
K\cdot|\delta|)=\bigO\big((|\varphi|+C\cdot K)\cdot|\delta|\big)$.
Note that the formula $\Phi_{3,C,K}$ is asymptotically shorter than
$\Phi_{1,C,K}$ and $\Phi_{2,C,K}$, but it contains an additional quantifier
alternation.

\subsection{Optimizations of formulas}
Finally, we mention three simple optimizations of the formula
construction, which are always applied in the rest of the paper.

The first optimization is based on the fact that every cycle is
completely included in the transition set $\delta_S$ of some SCC
$S$. Hence, all transitions $t$ that do not lead between states of the
same SCC can be completely ignored during the formula
construction. The acceptance marks on such a transition $t$ do not
affect the acceptance of any run as $t$ appears at most once on each
run. For these transitions $t$, we can define $\rem(t)$ such that
$\mks(\rem(t))=\emptyset$.

The second optimization is specific for $\Phi_{3,C,K}$. In the
construction of $\mcycle_3(\vec{e})$, we replace the subformula
$\bigvee_{t\in\delta}e_t$ enforcing the nonemptiness of $\Te$ by
$\mcycle_2(\vec{e})$. This modification prolongs the formula, but it
does not change the overall semantics of $\mcycle_3(\vec{e})$ and our
preliminary experiments showed that QBF solvers can often solve the
modified formula $\Phi_{3,C,K}$ faster.

The third optimization extends $\Phi_{j,C,K}$ into the conjunction
\[
   \Phi_{j,C,K}~\wedge \bigwedge_{c\in\{1,2,\ldots,C\}}\bigwedge_{k\in N_K} (\neg
   i_{c,k}\vee\neg f_{c,k}).
\]
The added part says that no cube contains both $\Inf k$ and $\Fin k$
for any $k$. A cube with both $\Inf k$ and $\Fin k$ would be useless
as it cannot be satisfied by any run.

We have also made some experiments with breaking the symmetries in the
formula models. In particular, we have ordered new acceptance marks by
their placements on transitions and we have ordered the cubes by their
content. As the effect of these modifications was inconclusive, we do
not describe it here.

% \todo{Zminit, ze cela formule
%   ma alepson 1 $\Inf$ nebo $\Fin$? Je to tak, Terko?}

% \subsection{SCC-based optimization}

% Now we present an optimized formula construction based on the fact
% that every cycle is completely included in the transition set
% $\delta_S$ of some SCC $S$. Note that we cannot reduce the number of
% acceptance marks in each SCC separately as all SCCs have to share the
% same acceptance formula after the reduction. However, for each SCC we
% can build the formula $\Phi_{C,K}$ separately and then we can put all
% these formulas into one conjunction such that they share the variables
% $\vec{i},\vec{f}$.

% Now we describe the construction of optimized QBF formulas
% $\Phi^\mathit{opt}_{j,C,K}$ formally. Given an automaton
% $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$ and its SCC $S$, by $\mA^S$ we
% denote the automaton corresponding to the part of $\mA$ delimited by
% $S$, i.e., $\mA^S=(S,M,\Sigma,q',\delta_S,\varphi)$ where $q'$ is an
% arbitrary state of $S$. Further, let $\vec{n}_S$ denote the vector of
% variables $n_{t,k}$ where $t\in\delta_S$ and $k\in N_K$. By
% $\Phi^S_{j,C,K}(\vec{n}_S,\vec{i},\vec{f})$ we denote the formula
% $\Phi_{j,C,K}$ constructed for $\mA^S$ as presented above.
% Finally, we define the optimized QBF formula as
% \[
%   \Phi^\mathit{opt}_{j,C,K}(\vec{n}',\vec{i},\vec{f})=\bigwedge_{\textrm{SCC }S}\Phi^S_{j,C,K}(\vec{n}_S,\vec{i},\vec{f})
% \]
% where $\vec{n}'$ is the vector of all varibles contained in vectors
% $\vec{n}_S$ for SCCs $S$.

% One effect of this optimization is that the formula
% $\Phi^\mathit{opt}_{j,C,K}$ contains no variables $n_{t,k}$ %and $e_t$
% for transitions $t$ that do not lead between states of the same SCC.
% The acceptance marks on such a transition $t$ do not affect the
% acceptance of any run as $t$ appears at most once on each run. For
% these transitions $t$, we can define $\rem(t)$ such that
% $\mks(\rem(t))=\emptyset$.

%}}}
%{{{ algorithm

\section{Reduction algorithm}\label{sec:algo}

This section explains how we use the QBF constructed in the
previous section to reduce the number of acceptance marks in TELA.
First, we describe a \emph{single-level} reduction, which
uses only a single kind of QBF. More precisely, we talk about
\emph{level~1}, \emph{level~2}, or \emph{level~3} reduction when
$\Phi_{1,C,K}$, $\Phi_{2,C,K}$, or
$\Phi_{3,C,K}$ is used, respectively.

% \begin{algorithm}[t]
%   \DontPrintSemicolon
%   \SetKwFunction{FextendBackward}{extendBackward}
%   \SetKwProg{PI}{Procedure}{}{}
%   \PI{$\mathit{SingleLevelReduction}(\mA,j,\mathit{reduceC})$}{
%     \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$, level $j\in\{1,2,3\}$, $\mathit{reduceC}\in\{\true,\false\}$}
%     \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
%     \;
%   %   \If{$L(\mA)=\emptyset$}{
%   % %      \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'=\{(p,a,\emptyset,q)\mid(p,a,M',q)\in\delta\}$
%   %       \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all acceptance marks removed
%   %     }
%     $C_\mA\gets$ the number of cubes in the acceptance formula of $\mA$ transformed to DNF\;
%     $K_\mA\gets$ the number of acceptance marks in $\mA$\;
%     $C\gets C_\mA$\;
%     $K\gets K_\mA$\;
%     $\mathit{stop}\gets\false$\;
%     \While(\tcp*[f]{reduction of the number of marks}){$\neg\mathit{stop}~\wedge~K>0$}{
%       $\Phi\gets\Phi^\mathit{opt}_{j,C,K{-}1}$ for $\mA$\;
%       \leIf{$\mathit{satisfiable}(\Phi)$}{$K\gets K{-}1$}{$\mathit{stop}\gets\true$}
%     }
%     \If(\tcp*[f]{check whether the condition $\false$ fits}){$K=1~\wedge~\mathit{stop}$}{
%       $\Phi\gets\Phi^\mathit{opt}_{j,0,0}$ for $\mA$\; 
%       \If{$\mathit{satisfiable}(\Phi)$}{
%         \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all marks removed
%       }
%     }  
%     \If(\tcp*[f]{reduction of the number of cubes}){$\mathit{reduceC}$}{
%       $\mathit{stop}\gets\false$\;
%       \While{$\neg\mathit{stop}~\wedge~C>1$}{
%         $\Phi\gets\Phi_{j,C-1,K}$ for $\mA$\;
%         \leIf{$\mathit{satisfiable}(\Phi)$}{$C\gets C{-}1$}{$\mathit{stop}\gets\true$}
%       }
%     }
%     \eIf{$K=K_\mA~\wedge~C=C_\mA$}{
%       \KwRet $\mA$
%     }{
%       compute $\rem$ and $\psi$ from a model of $\Phi_{j,C,K}$\;
%       \KwRet $(Q,N_K,\Sigma,q_I,\rem(\delta),\psi)$
%     }
%   }\;
%   \caption{The single-level reduction procedure}
%   \label{alg:single}
% \end{algorithm}

\begin{algorithm}[t]
  \DontPrintSemicolon
  \SetKwFunction{FextendBackward}{extendBackward}
  \SetKwProg{PI}{Procedure}{}{}
  \PI{$\mathit{SingleLevelReduction}(\mA,j,\mathit{reduceC})$}{
    \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$, $j\in\{1,2,3\}$, $\mathit{reduceC}\in\{\true,\false\}$}
    \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
    \;
  %   \If{$L(\mA)=\emptyset$}{
  % %      \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'=\{(p,a,\emptyset,q)\mid(p,a,M',q)\in\delta\}$
  %       \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all acceptance marks removed
  %     }
    $C_\mA\gets$ the number of cubes in the formula $\varphi$ transformed to~DNF\;
    $K_\mA\gets$ the number of acceptance marks in $\mA$\;
    $C\gets C_\mA$\;
    $K\gets K_\mA$\;
%    \While(\tcp*[f]{reduction of the number of marks}){$K>1~\wedge~\mathit{satisfiable}(\Phi_{j,C,K{-}1})$}{$K\gets K{-}1$}
    \lWhile{$K>1~\wedge~\mathit{satisfiable}(\Phi_{j,C,K{-}1})$}{$K\gets K{-}1$}
    \If{$K=1$}{
      \If(\tcp*[f]{check the condition $\true$}){all cycles in $\mA$ are accepting}{ %$\mathit{satisfiable}(\Phi_{j,1,0})$}{
        \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\true)$ where $\delta'$ is $\delta$ with all marks removed
      }
      \If(\tcp*[f]{check the condition $\false$}){all cycles in $\mA$ are rejecting}{ %$\mathit{satisfiable}(\Phi_{j,0,0})$}{
        \KwRet $(Q,\emptyset,\Sigma,\delta',q_I,\false)$ where $\delta'$ is $\delta$ with all marks removed
      }
    }  
    \If(\tcp*[f]{reduction of the number of cubes}){$\mathit{reduceC}$}{
      \lWhile{$C>1~\wedge~\mathit{satisfiable}(\Phi_{j,C-1,K})$}{$C\gets C{-}1$}
    }
    \If{$K<K_\mA~\vee~C<C_\mA$}{
      compute $\rem$ and $\psi$ from a model of $\Phi_{j,C,K}$\;
      \KwRet $(Q,N_K,\Sigma,\rem(\delta),q_I,\psi)$
    }
    \KwRet $\mA$
  }\;
  \caption{The single-level reduction procedure}
  \label{alg:single}
\end{algorithm}

The reduction procedure called $\mathit{SingleLevelReduction}$ is
given in Algorithm~\ref{alg:single}. Besides the reduction of
acceptance marks, the algorithm also reduces the number of cubes in the acceptance formula if the last argument $\mathit{reduceC}$ is set to
$\true$.
% In the first step, the procedure checks whether the input
% automaton represents the empty language and if this is the case, it
% returns the same automaton with acceptance conditon $\false$ and with
% all acceptance marks removed. Otherwise it
The first \textbf{while} loop gradually decreases the number of marks
until $K=1$ is reached or the QBF solver behind the function
$\mathit{satisfiable}(\Phi_{j,C,K{-}1})$ fails to reduce
the number of marks, i.e., it claims unsatisfiability of the formula
or it runs out of resources. If the loop ends with $K=1$, we check
whether an acceptance condition without any mark (i.e., $\true$ or
$\false$) can be used. These checks are based on an inspection of the
automaton rather than on QBF solving. If some of the checks succeeds,
we return the corresponding automaton without any acceptance
mark. Otherwise, if $\mathit{reduceC}$ is set to $\true$ then the
procedure gradually reduces the number of cubes in the second
\textbf{while} loop. Note that the loop never checks for acceptance
condition with 0 cubes as it is equivalent to $\false$ and this case
was treated above. Finally, if the procedure succeeds to reduce the
number of marks or cubes, it constructs the modified
automaton. Otherwise, it returns the original automaton.

The algorithm can be reformulated to use an incremental approach
instead of building a new formula in each iteration of the
\textbf{while} loops. The incremental version of the first
\textbf{while} loop builds the formula
$\Phi=\Phi_{j,C,K{-}1}$ only in the first iteration. In
each subsequent iteration, it extends this formula with a condition
saying that one more mark is not used in the automaton, i.e., the mark
is neither on edges, nor in the acceptance formula. For example, if we
want to say that the mark $k\in N_K$ is not used, we replace $\Phi$ by
\[
  \Phi~\wedge~\bigwedge_{t\in\delta}\neg n_{t,k}~\wedge\bigwedge_{c\in\{1,2,\ldots C\}}(\neg i_{c,k}\wedge\neg f_{c,k}).
\]
The second \textbf{while} loop can be transformed to an incremental
version similarly. The incremental approach benefits from the fact
that some QBF solvers can decide an extended formula faster as they
reuse the information computed when solving the original formula.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[smallautomaton]
    \begin{scope}[initial angle=90,xshift=-3.5cm]
      \node (l) at (1,1.3) {automaton $\mA$};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={1}{1}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic[pos=.33] {acc={2}{2}} pic[pos=.67] {acc={3}{3}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={3}{3}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$(\Fin\tacc{1}{1}\wedge\Inf\tacc{2}{2})\vee(\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}\wedge\Inf\tacc{3}{3})$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=3.5cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,1,\true)$}; %{level 1:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={2}{2}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic[pos=.33] {acc={0}{0}} pic[pos=.67] {acc={2}{2}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={1}{1}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}\wedge\Inf\tacc{2}{2}$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=-3.5cm,yshift=-4.1cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,2,\true)$}; %{level 2:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic {acc={0}{0}} pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {acc={1}{1}} pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Inf\tacc{0}{0}\wedge\Fin\tacc{1}{1}$};
    \end{scope}
    \begin{scope}[initial angle=90,xshift=3.5cm,yshift=-4.1cm]
      \node (l) at (1,1.3) {$\mathit{SingleLevelReduction}(\mA,3,\true)$}; %{level 3:};
      \node[state,initial] (p) at (0,0) {};
      \node[state] (q) at (2,0) {};
      \path[->,auto]
      (p) edge[out=-150,in=150,looseness=10] pic {acc={0}{0}} pic {l=$a$} (p)
      (p) edge[out=30,in=150] pic {acc={0}{0}} pic {l=$b$} (q)
      (q) edge[out=30,in=-30,looseness=10] pic {l=$c$} (q)
      (q) edge[out=-150,in=-30] pic {l=$d$} (p);

      \node[acclabel] at (1,-1.4)
      {$\Fin\tacc{0}{0}$};
    \end{scope}
  \end{tikzpicture}
  \smallskip
  
  \caption{An example illustrating the results of the three
    single-level reductions: an input automaton $\mA$ and the automata
    obtained by reducing it with level 1, level 2, and level~3.}
  \label{fig:example}
\end{figure}

Figure~\ref{fig:example} shows a very simple automaton $\mA$ and the
three automata produced by calls of
$\mathit{SingleLevelReduction}(\mA,j,\true)$ for $j\in\{1,2,3\}$. The
figure clearly illustrates that the higher level of reduction we use,
the more acceptance marks can be reduced. On the other side, lower
levels are typically faster. The best results can be often achieved by
combining reductions of all levels. We call this approach
\emph{multi-level} reduction. It is a straightforward sequential
application of the three levels, see Algorithm~\ref{alg:multi}.

\begin{algorithm}[t]
  \DontPrintSemicolon
  \SetKwFunction{FextendBackward}{extendBackward}
  \SetKwProg{PI}{Procedure}{}{}
  \PI{$\mathit{MultiLevelReduction}(\mA,\mathit{reduceC})$}{
    \KwIn{TELA $\mA=(Q,M,\Sigma,\delta,q_I,\varphi)$ and $\mathit{reduceC}\in\{\true,\false\}$}
    \KwOut{an equivalent TELA with the same structure as $\mA$ and with at most as many acceptance marks as in $\mA$} %with the same or lower number of acceptance~marks}
    \;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,1,\false)$\;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,2,\false)$\;
    $\mA\gets\mathit{SingleLevelReduction}(\mA,3,\mathit{reduceC})$\;
    \KwRet $\mA$
  }\;
  \caption{The multi-level reduction procedure}
  \label{alg:multi}
\end{algorithm}

%}}}
%{{{ implementation

\section{Implementation}\label{sec:implementation}

The presented reduction algorithms have been implemented in a tool
called \telatko. It is implemented in Python 3 and uses the Spot
library~\cite{duret.16.atva2} for automata parsing and manipulation,
and the theorem prover Z3~\cite{demoura.08.tacas} to solve the
satisfiability of QBF transformed to prenex normal form (and not using
CNF). Our tool is available at
\begin{center}
\url{https://gitlab.fi.muni.cz/xschwar3/telatko}
\end{center}
under the GNU GPLv3
license. The tool can be executed by the command 
\begin{center}
  \texttt{telatko -F <input.hoa> [-L }$j$\texttt{] [-C] [-I] [-T }$t$\texttt{] [-O <output.hoa>]}
\end{center}
where
\begin{description}
\item[\texttt{-F <input.hoa>}] specifies the file with the input automaton in HOA format~\cite{babiak.15.cav}, 
\item[\texttt{-L }$j$] specifies the reduction level; if omitted, the multi-level reduction is used,
\item[\texttt{-C}] switches on the reduction of the number of cubes
  after the number of marks is reduced (it corresponds to
  $\mathit{reduceC}=\true$ in Algorithms~\ref{alg:single}
  and~\ref{alg:multi}),
\item[\texttt{-I}] switches on the incremental version,
\item[\texttt{-T }$t$] sets the timeout for each QBF query to $t$ seconds (the default value is 50 seconds), 
\item[\texttt{-O <output.hoa>}] specifies the output file; if omitted,
  the produced automaton is sent to \textit{stdout} in the HOA format.
\end{description}

If some call of the function $\mathit{satisfiable}(\Phi_{j,C,K{-}1})$
in the first \textbf{while} loop of Algorithm~\ref{alg:single} does
not return $\true$, then the name of the output automaton (included in
the generated HOA) encodes the reason for it. In the case of a single
level reduction, the name has the form \texttt{L$j$\_$k$\_$X$}, where
$j$ is the considered level, $k=K-1$ is the number of acceptance marks
considered by the formula, $X$ is either \texttt{U} if the formula is
unsatisfiable or \texttt{T} if the solver did not decide within the
time limit. If $X$ is \texttt{T}, a longer timeout may lead to further
reductions. If the multi-level reduction is used, the automaton name
contains the information from all levels. For example, the name
`\texttt{L1\_5\_U L2\_3\_U L3\_1\_T}' means that level 1 reduced the
number of marks to 6 (reduction to 5 is impossible on this level),
level 2 reduced it to 4, and level 3 to 2 as the QBF solver did not
finish in the time limit when trying to reduce the number of marks to
1.%when trying the automaton may be potentially reduced further.

% that does not . 
% The parameters of the last query of the QBF solver are encoded in the name of the automaton.

% The name of the automaton is in the following format:
% \begin{center}
%   \texttt{level\_marks\_solver}
% \end{center}
% where 
% \begin{itemize}
%     \item \texttt{level} $\in \{L1, L2, L3, T, F\}$ and it gives us the information about which level of simplification was applied (or in case of $T$ and $F$ if the acceptance formula can be $\true$ or $\false$).
%     \item \texttt{marks} $\in \mathbf{N}$ representing the number of marks we built the formula for.
%     \item \texttt{solver} $\in \{U, T, S\}$ where $U$ means that the query was unsatisfiable, $T$ means the solver timeouted and $S$ means that the simplification is satisfiable.
% \end{itemize}

% Note that we are only interested in the result of the last query, therefore we get the information that the simplification was satisfiable only if the result automaton has zero acceptance marks. Meaning that the acceptance condition is either $\true$ or $\false$.

%}}}
%{{{ experimental evaluation 

\section{Experimental evaluation}\label{sec:experiments}

To evaluate our reduction technique, we applied \telatko to automata
produced by the following process. We started with two sets of LTL formulas.
\begin{itemize}
\item One set contains all LTL formulas from \emph{literature} that
  are provided by the tool \texttt{genltl} of the Spot
  library~\cite{duret.16.atva2}~2.10.4. For parametrized formula
  patterns, we consider instances for all combinations of parameter
  values from 1 to 4.
\item The second set consists of 400 random LTL formulas with 4 atomic
  propositions. These formulas were generated by the tool
  \texttt{randltl} of the Spot library.
\end{itemize}
On both these sets, we applied the tool \texttt{ltlfilt} of the Spot
library to simplify the formulas and remove duplicates and formulas
equivalent to $\true$ and $\false$. After these steps, we had 348
LTL formulas from literature and 335 random formulas.
%
Formulas from both sets have been translated to nondeterministic TELA
by two state-of-the-art translators, namely \texttt{ltl2tgba} (used
with option \texttt{-G}) from the Spot library~\cite{duret.16.atva2}
and \texttt{ltl3tela}~\cite{major.19.atva}, and to deterministic TELA
by \texttt{ltl3tela} with option \texttt{-D1} and by another two
state-of-the-art translators from the Owl
library~\cite{kretinsky.18.atva}, namely \texttt{ltl2dela} (known as
Delag)~\cite{muller.17.gandalf} and \texttt{ltl2dgra} (known as
Rabinizer~4)~\cite{kretinsky.18.cav}. Some translators failed on some
formulas: it usually reached a timeout of 60 seconds or it produced an
automaton that cannot be parsed by the Spot library.
% produced by the individual tools contains less than 348 automata as not
% all of the formulas are successfully translated due to a timeout of 60
% seconds.
Further, we have removed automata with 0 or 1 acceptance mark as
there is a little point in reducing these. Table
\ref{tab:ltltranslators} shows the exact versions of the
translators. For each set of formulas and for each translator, it also
provides the number of fails, the number of produced automata with
less than two marks, and the number of automata with at least two
marks. The numbers of automata with at least two marks are typeset in
bold as these automata are actually used for the experimental
evaluation of our reduction technique.

\begin{table}[t]
  \caption{Considered translators and the numbers of \emph{fails} and
    successfully constructed automata with \emph{at most 1 mark} and
    with \emph{at least 2 marks} for each translator and set of
    formulas.}
\label{tab:ltltranslators}
\centering
% \begin{tabular}{lr@{~~~~~~}lr}
% \toprule
% tool        & version&homepage & ~~~automata \\
% \midrule
% \texttt{ltl2dela}~~~ & 21.0 & \multirow{2}{*}{\url{https://owl.model.in.tum.de/}} & 129\\
% \texttt{ltl2dgra} & 21.0 & & 234\\
% \texttt{ltl2tgba} & 2.10.4 & \url{https://spot.lrde.epita.fr} & 70\\
% \texttt{ltl3tela} & 2.2.0  & \url{https://github.com/jurajmajor/ltl3tela} & 91\\
% \bottomrule
% \end{tabular}
%
% \begin{tabular}{lrrrr}
%   \toprule
%   &&& \multicolumn{2}{c}{constructed automata with} \\ \cmidrule(lr){4-5}
%   tool &\!\!\!version/homepage & ~~~~fails & less than 2 marks & \textbf{at least 2 marks}\\
%   \midrule
%   \texttt{ltl2dela} & 21.0\tablefootnote{\label{fn:owl}\url{https://owl.model.in.tum.de/}}
%        & 5 & 214 & \textbf{129} \\
%   \texttt{ltl2dgra} & 21.0\footnotemark[1]
%        & 12 & 102 & \textbf{234}\\
%   \texttt{ltl2tgba} & 2.10.4\tablefootnote{\url{https://spot.lrde.epita.fr}}
%        & 0 & 278 & \textbf{70}\\
%   \texttt{ltl3tela} & 2.2.0\tablefootnote{\url{https://github.com/jurajmajor/ltl3tela}}
%        & 18 & 239 & \textbf{91}\\
%   \bottomrule
% \end{tabular}
%
\setlength{\tabcolsep}{5.7pt}
\begin{tabular}{lrrrrrrr}
  \toprule
  && \multicolumn{3}{c}{\!348 formulas from literature\!} & \multicolumn{3}{c}{335 random formulas}\\
  \cmidrule(lr){3-5} \cmidrule(lr){6-8}
  &&& \multicolumn{2}{c}{automata with} && \multicolumn{2}{c}{automata with}\\
  \cmidrule(lr){4-5} \cmidrule(lr){7-8}
  \multicolumn{2}{l}{translator ~~~ (version)$^{\text{web}}$}
  & ~~~~fails & \makecell[r]{at most\\[-1ex] 1 mark} & \makecell[r]{\textbf{at least}\\[-1ex] \textbf{2 marks}}
  & ~~~~fails & \makecell[r]{at most\\[-1ex] 1 mark} & \makecell[r]{\textbf{at least}\\[-1ex] \textbf{2 marks}}\\
  % &&& at most & \textbf{at least} && at most & \textbf{at least}\\[-.8ex]
  % \multicolumn{2}{l}{translator ~~~ (version)$^{\text{web}}$} & ~~~~fails & 1 mark & \!\!\!\!\textbf{2 marks} & ~~~~fails & 1 mark & \!\!\!\!\textbf{2 marks}\\
  \midrule 
  \texttt{ltl2tgba -G} & (2.10.4)\tablefootnote{\url{https://spot.lrde.epita.fr}}
  & 0 & 278 & \textbf{70} & 0 & 320 & \textbf{15}\\
  \texttt{ltl3tela} & (2.2.0)\tablefootnote{\url{https://github.com/jurajmajor/ltl3tela}}
  & 18 & 239 & \textbf{91} & 0 & 286 & \textbf{49}\\
  \texttt{ltl3tela -D1} & (2.2.0)\footnotemark[2]
  & 20 & 247 & \textbf{81} & 0 & 291 & \textbf{44}\\ 
  \texttt{ltl2dela} & (21.0)\tablefootnote{\label{fn:owl}\url{https://owl.model.in.tum.de/}}
  & 5 & 214 & \textbf{129} & 0 & 246 & \textbf{89}\\
  \texttt{ltl2dgra} & (21.0)\footnotemark[3]
  & 12 & 102 & \textbf{234} & 0 & 130 & \textbf{205}\\
  \bottomrule
\end{tabular}
\end{table}

To each automata set (that is, the automata with at least two marks
produced by an individual LTL translator for one of the two formula
sets), we have applied all single-level reductions and the multi-level
reduction, always with incremental approach and without reducing the
number of cubes. We do not reduce the number of cubes as our primary
aim is to reduce the number of acceptance marks.
%\todo{Vysvetlit, proc neredukujeme pocet cubes?}
The timeout for each QBF query was set to 30 seconds.
%
All reductions have been performed by the tool \texttt{telatko}
built with Spot library version 2.10.4 and Z3 version 4.8.15. The
experiments have been run on a computer with Intel$^\text{®}$ Core™ i7-8700
processor and 32 GB of memory running Ubuntu 20.04.4. We used the tool
\texttt{autcross} of the Spot library to get the statistics of the
reduced automata and the running times.

For each automata set identified by the translator and the set of
formulas, Table~\ref{tab:cumm-data} shows the cumulative numbers of
marks in the input automata sets and after each reduction, together
with the reduction ratio and total time spent by the considered
reduction. The column \textit{solver timeout} shows the number of
automata for which the last query to QBF solver did not finish within
the 30~seconds limit. The timeout of the last QBF query means that the
automaton may be potentially further reduced if a longer time limit is
used. \fixme{Zkontrolovat zbytek odstavce podle aktualnich vysledku,
  specifikovat formula set.} One can observe that a higher level
sometimes achieves a smaller reduction than a lower level (e.g.,
compare level~1 and level~2 for \texttt{ltl2dgra}). This is caused by
the QBF solver timeouts occuring earlier as formulas constructed by
the higher level are more complex. For \texttt{ltl2dela} and
\texttt{ltl2dgra}, the automata sets do not contain any automaton
where level~2 or level~3 achieves a better result than
level~1. However, all levels contribute to the reductions in the
multi-level setting.

\begin{table}[t]
  \caption{The cumulative numbers of acceptance marks before and after
    reduction for various reduction levels and automata sets given by
    the translator and formula set. The column \emph{reduction} shows
    the cumulative percentage of saved acceptance marks and
    \emph{time} reports the cumulative reduction time. The column
    \textit{solver timeout} indicates the number of instances where
    the last call to the QBF solver timed out.  }
\label{tab:cumm-data}
\centering
\setlength{\tabcolsep}{3.9pt}
\newcommand{\mybox}[1]{\fbox{\begin{minipage}{4.7cm}\centering#1\end{minipage}}}
\begin{tabular}{lcrrrrrrrr}
  \toprule
  && \multicolumn{4}{c}{\makecell{reduction of marks in automata\\[-.8ex] from formulas from literature}}
  & \multicolumn{4}{c}{\makecell{reduction of marks in automata\\[-.8ex] from random formulas}}
  \\ \cmidrule(lr){3-6} \cmidrule(lr){7-10}
  translator & \makecell{reduction\\[-1ex] level}
  & marks & \makecell{reduction\\[-1ex] [\%]} & \makecell{time\\[-1ex] [s]} & \makecell{solver\\[-1ex] timeout} 
  & marks & \makecell{reduction\\[-1ex] [\%]} & \makecell{time\\[-1ex] [s]} & \makecell{solver\\[-1ex] timeout} \\
  \midrule
%  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl2tgba -G}} 
  & \multicolumn{4}{c}{\mybox{198 marks in 70 automata}}
  & \multicolumn{4}{c}{\mybox{32 marks in 15 automata}}\\
  & 1
  & 198 & 0.0~~~ & 48.5 & 0~~~
  &   32 &   0.0~~~ &    8.4 & 0~~~ \\                     
  & 2
  & 198 & 0.0~~~ & 65.2 & 0~~~
  &   31 &   3.1~~~ &    9.4 & 0~~~ \\                     
  & 3
  & 189 & 4.5~~~ & 409.8 & 7~~~
  &   26 &   18.8~~~ &    43.9 & 1~~~ \\                     
  & multi
  & 189 & 4.5~~~ & 427.6 & 7~~~
  &   26 &   18.8~~~ &    44.9 & 1~~~ \\                    
  \midrule
%  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl3tela}} 
  & \multicolumn{4}{c}{\mybox{348 marks in 91 automata}}
  & \multicolumn{4}{c}{\mybox{120 marks in 49 automata}}\\
  & 1
  & 332 & 4.6~~~ & 530.3 & 13~~~
  &   101 &   15.8~~~ &     32.4 &  0~~~ \\                     
  & 2
  & 334 & 4.0~~~ & 551.0 & 14~~~
  &   100 &   16.7~~~ &     32.3 &  0~~~ \\                     
  & 3
  & 326 & 6.3~~~ & 698.5 & 18~~~
  &   95 &   20.8~~~ &     66.9 &  1~~~ \\                     
  & multi
  & 319 & 8.3~~~ & 1619.2 & 18~~~
  &   95 &   20.8~~~ &    73.4 & 1~~~ \\                    
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl3tela -D1}} 
  & \multicolumn{4}{c}{\mybox{272 marks in 81 automata}}
  & \multicolumn{4}{c}{\mybox{97 marks in 44 automata}}\\
  & 1
  & 272 & 0.0~~~ & 383.1 & 9~~~
  &   95 &   2.1~~~ &     23.8 &  0~~~ \\                     
  & 2
  & 272 & 0.0~~~ & 386.6 & 10~~~
  &   95 &   2.1~~~ &     24.6 &  0~~~ \\                     
  & 3
  & 272 & 0.0~~~ & 950.2 & 14~~~
  &   92 &   5.2~~~ &     54.1 &  0~~~ \\                     
  & multi
  & 272 & 0.0~~~ & 1659.6 & 16~~~
  &   92 &   5.2~~~ &    67.2 & 1~~~ \\                    
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl2dgra}} 
  & \multicolumn{4}{c}{\mybox{882 marks in 234 automata}}
  & \multicolumn{4}{c}{\mybox{491 marks in 205 automata}}\\
  & 1
  & 544 & 38.3~~~ & 859.1 & 14~~~
  &   293 &   40.3~~~ &     275.6 &  0~~~ \\                     
  & 2
  & 554 & 37.2~~~ & 1073.5 & 17~~~
  &   280 &   43.0~~~ &     283.9 &  0~~~ \\                     
  & 3
  & 553 & 37.3~~~ & 1349.7 & 22~~~
  &   267 &   45.6~~~ &     433.6 &  3~~~ \\                     
  & multi
  & 535 & 39.3~~~ & 2434.0 & 23~~~
  &   264 &   46.2~~~ &    411.7 & 2~~~ \\                    
  \midrule
  %  \multirow{5}{*}{\makecell{\texttt{ltl2tgba -G}}} &
  \multicolumn{2}{l}{\texttt{ltl2dela}} 
  & \multicolumn{4}{c}{\mybox{348 marks in 91 automata}}
  & \multicolumn{4}{c}{\mybox{234 marks in 89 automata}}\\
  & 1
  & 332 & 4.6~~~ & 465.9 & 12~~~
  &   154 &   34.2~~~ &     89.0 &  0~~~ \\                     
  & 2
  & 334 & 4.0~~~ & 553.9 & 15~~~
  &   153 &   34.6~~~ &     123.6 &  0~~~ \\                     
  & 3
  & 326 & 6.3~~~ & 691.8 & 18~~~
  &   149 &   36.3~~~ &     172.7 &  2~~~ \\                     
  & multi
  & 323 & 7.2~~~ & 1545.9 & 18~~~
  &   148 &   36.8~~~ &    219.8 & 2~~~ \\                    

% \\
% level 1 &
% 387~ & 26.0~~~~~~ & 755.4~ &  18~~~
% \\
% &
% level 2 &
% 390~ & 25.4~~~~~~ & 1024.5~ &  20~~~
% \\
% &
% level 3 &
% 393~ & 24.9~~~~~~ & 7273.3~ &  25~~~
% \\
% &
% multi &
% 371~ & 29.1~~~~~~ & 9111.4~ &  21~~~
% \\
% \midrule
% \multirow{4}{*}{\makecell{\texttt{ltl2dgra}\\234 automata\\882 acc.~marks}}
% &
% level 1 &
% 552~ & 37.4~~~~~~ & 738.7~ & 14~~~
% \\
% &
% level 2 &
% 569~ & 35.5~~~~~~ & 907.3~ &  18~~~
% \\
% &
% level 3 &
% 561~ & 36.4~~~~~~ & 1163.4~ &  21~~~
% \\
% &
% multi &
% 542~ & 38.5~~~~~~ & 2320.7~ &  21~~~
% \\
% \midrule
% \multirow{4}{*}{\makecell{\texttt{ltl3tela}\\91 automata\\348 acc.~marks}}
% &
% level 1 &
% 332~ & 4.6~~~~~~ & 465.9~ &  12~~~
% \\
% &
% level 2 &
% 334~ & 4.0~~~~~~ & 553.9~ &  15~~~
% \\
% &
% level 3 &
% 326~ & 6.3~~~~~~ & 691.8~ &  18~~~
% \\
% &
% multi &
% 323~ & 7.2~~~~~~ & 1545.9~ & 18~~~
% \\
\bottomrule                                                                     
\end{tabular}
\end{table}

\fixme{Upravit zbytek textu.}
Table~\ref{tab:heatmap} shows the number of automata from all
four sets that have a given number of original acceptance marks and a
given number of acceptance marks after multi-level reduction. The
table indicates that in many cases only 1 or 2~marks can be
saved. However, the achieved reduction is substantial for some
automata with a higher number of original acceptance marks. For
example, in 24 cases, we have reduced 7 or more
acceptance marks to only 4.
% Moreover, there were many timeouts of the last QBF query for manof these automata.
% Let us note that some that some reductions are the results are promising, e.g. in 17 cases, we have successfully
% reduced 8 or more acceptance marks to only 4.

\begin{table}[b!]
\caption{The effect of multi-level reduction.
A cell on coordinates $(x,y)$ contains the number of automata that have been
reduced from $x$ to $y$ acceptance marks. If the cell contains a sum of two
numbers, the latter represents the number of automata where the attempt to reduce
another mark has been unsuccessful due to a QBF solver timeout.}
\label{tab:heatmap}
\setlength{\tabcolsep}{2.5pt}
\centering
\input{table-heatmap.tex}
\end{table}

Figure~\ref{fig:quantile} presents the time spent by multi-level
reduction on individual automata of each automata set. The chart
shows a pleasing finding that for every set, most automata are reduced
in under a second and the high cumulative running times are caused by 
a relatively small number of complicated automata.

\begin{figure}[t]
  \caption{Performance of \telatko on individual automata of each automata sets.
    The graph shows the time ($y$ axis) needed by \telatko
    to process the $x$-th automaton of the set, where automata of each set are ordered by their processing time.
    % The $x$ axis represents the number of automata from each automata
    % set that are processed by \telatko in the time shown on the $y$
    % axis.
  }
\label{fig:quantile}
\bigskip
\centering
\input{quantile.tex}
\end{figure}

% Pridat do experimentu nejaky graf, ktery ukaze, jak rychle se nektere
% automaty redukovaly na minimum? Nebo spis ukazat vliv timeoutu na
% redukce?  (zvysovat timeout od 1s do 50s a vzdy ukazat miru
% redukce). Ty redukce ukazovat nejak jinak nez jen celkovym cislem
% (boxplot? Scatterplot?).

% Zkusit upravit redukci tak, aby vysledkem bylo TGBA a zkusit dale
% redukovat akceptacni znacky TGBA automatu redukovanych Spotem?

% Chceme ukazovat, ze redukce znacek muze nekdy umoznit dalsi redukci stavu?

%}}}
%{{{ conclusion

\section{Conclusions}\label{sec:conclusion}

We have presented a method reducing the number of acceptance marks in
transition-based Emerson-Lei automata with use of QBF solving and
without altering automata structure. We have implemented the method in
a tool called \texttt{telatko}. The current applications of the tool
are twofold. First, it can reduce the number of acceptance marks of a
given TELA. Second, it discloses how tools producing TELA are
economical with acceptance marks. The presented experimental results
show that the tool can indeed reduce the number of acceptance marks in
automata produced by all considered state-of-the-art LTL to automata
translators on formulas from literature. Further, it clearly shows
that the translators of the Owl library are significantly less
economical with acceptance marks than the other two translators.

The reduction of acceptance marks is not the only application of the
presented approach. For example, it can be easily adapted to look for
an equivalent automaton with the same structure and an acceptance
formula of a specific form (e.g., without any $\Fin m$ atoms). Even
though the QBF queries can be time-consuming, in practice one can
often find a good trade-off between speed and efficiency by adjusting 
the formula precision and choosing a reasonable timeout.

In the future, we plan to improve the reduction process (e.g., use the
bisection method to reduce the number of acceptance marks more
efficiently) and study whether the reduction of acceptance condition
can enable further reductions or simplifications of automata
structures.

%}}}

% \section{TODO}

% \noindent
% Do budoucna:
% \begin{itemize}
% \item level 1 bez SCC optimalizace
% \item nahradit weak SCC jednou hranou pro neakceptujici a jinou pro akceptujici
% \item sladit konstrukci QBF formuli s implementaci
% \item podivat se znovu na uzitecnost a potrebnost optimalizaci typu ``klauzule neni false'' a ``alespon jedna klauzule je neprazdna''
% \item sladit popis algoritmu s implementaci
% \item v experimentech nejak sledovat vztah usetreneho casu a usetrenych znacek?
% \item zkusit aplikovat na jine typy automatu (treba TGBA nebo Rabin)?
% \item zkusit, zda/jak redukce znacek umozni redukovat stavovy prostor
% \end{itemize}

%\bibliographystyle{abbrvnat}
\bibliography{mc}

\end{document}

%{{{ standard reductions

\section{Reduction based on acceptance marks relations}\label{sec:standard}

This section presents a reduction technique based on relations between
acceptance sets restricted to individual SCCs. It employs the fact
that acceptance of a run always depends only on a single SCC, namely
the SCC that contains the whole run except some finite prefix.

Let $\mA$ be a TELA with the acceptance condition $\varphi$. We assume
that $\varphi$ is in DNF. This technique has two steps.
\begin{enumerate}
\item For each SCC $S$, we make a copy $\varphi_S$ of $\varphi$ and
  simplify it according to relations between acceptance sets
  restricted to $\delta_S$. 
\item We collect the simplified acceptance conditions
  $\varphi_{S_1},\ldots,\varphi_{S_k}$ of all SCCs and merge them into
  one acceptance condition $\varphi'$. Additionally, we sometimes add
  acceptance marks to all transitions of some SCCs to make the
  resulting automaton with acceptance formula $\varphi'$ equivalent to
  the original automaton.
\end{enumerate}

% Let $\mathcal{A}$ be an original automaton and let $\psi$ be an
% acceptance condition of $\mathcal{A}$. Every run of $\mathcal{A}$ has
% an infinite suffix that takes place within one SCC $S_{i}$. Thus the
% evaluation of $\psi$ depends purely on the SCC $S_{i}$ and we can
% optimize the acceptance condition for each SCC separately. This
% optimization consists of removing redundant terms from acceptance
% condition and relabeling of acceptance marks on the transitions. The
% state and transition structure of the SCC does not change. This way we
% obtain set of simplified acceptance conditions that we merge into new
% acceptance formula $\psi'$. The automaton with relabeled transitons
% and new acceptance condition $\psi'$ we denote $\mathcal{A}'$.
% Finally, we ensure that automaton $\mathcal{A'}$ is equivalent to the
% original automaton $\mathcal{A}$.

\subsection{Simplification of $\varphi_S$ for an SCC $S$}\label{ssec:step1}
Recall that $\varphi_S$ is in DNF. Hence, we can represent it as a set
$\varphi_S=\{D_1,\ldots,D_k\}$ of disjunctive clauses.





Since formula $\psi_{i}$ is in DNF, we can represent it as a set of disjuncts $\overline{\psi_{i}} = \{D_1, D_2, \ldots D_k\}$.

Let $D_{k} \in \overline{\psi_{i}}$ be a disjunct of formula $\overline{\psi_{i}}$ and $C_{j} \in D_{k}$ a conjunct of disjunct $D_{k}$. Furthermore let  $\tacc{0}{i}, \tacc{4}{j}, \tacc{8}{k}, \tacc{2}{l} \in M$ be distinct acceptance marks that occur in $\mathcal{A}$.

In the next section, some properties of an automaton allow us to substitute a Boolean value $\true$ or $\false$ for a particular term of the formula $\psi_i$.
The consequences of this substitution are divided into a number of cases. We represent it on the set-format of formula we just defined.

\begin{itemize}
    \item If $C_{j}$ is substituted by $\true$, the conjunct is omitted from $D_{k}$. Thus $D_{k} = D_{k} \setminus \{C_{j}\}$.
    \item If $C_{j}$ is substituted by $\false$, the conjunct causes that the whole $D_{k}$ evaluates to $\false$. Thus $\overline{\psi_{i}} = \overline{\psi_{i}} \setminus \{D_{k}\}$.

\end{itemize}

That being said, we can define the reduction techniques. 

\subsubsection{Acceptance formula modifications\\} 
\label{subsection:acc_modif}
Since we optimize for each SCC separately, the acceptance formula corresponding to SCC $S_{i}$ can contain terms with acceptance marks that are not present on the transitions of $S_{i}$.
Let $\tacc{8}{k} \in M$ be an acceptance mark that is not present on any edge of $S_{i}$. Then any term that contains this acceptance mark in $\overline{\psi_{i}}$ can be immediately substituted with a boolean value and thus removed from $\overline{\psi_{i}}$.
\medskip

Therefore acceptance mark $\tacc{8}{k}$ is not visited in any run of $S_{i}$ and thus every term in form $\Fin\tacc{8}{k}$ is substituted with $\true$ and every term $\Inf\tacc{8}{k}$ is substituted with $\false$.

On the contrary, let $\tacc{4}{j}$ be an acceptance mark that is present on every transition of $S_{i}$. That means that at least one transition with $\tacc{4}{j}$ is visited infinitely often by a run of $\mathcal{S_{i}}$. Thus every term $\Fin\tacc{4}{j}$ is substituted by $\false$ and every term in form $\Inf\tacc{4}{j}$ is substituted by $\true$. 

\subsubsection{$\Inf$ conjuncts\\}
\label{subsection:simpl_inf}
Reduction of a conjunct of $\Inf\tacc{8}{k}$ form  is based on the inclusion of the sets of edges labeled with $\tacc{8}{k}$ and set of edges labeled with $\tacc{4}{j}$. If all transitions that contain an acceptance mark $\tacc{8}{k}$ also contain $\tacc{4}{j}$, we can remove $\Inf\tacc{4}{j}$ from all disjuncts, where it occurs together with $\Inf\tacc{8}{k}$. 
More formally, if the following conditions hold:
\begin{itemize}
    \item $Z(\tacc{8}{k}) \subseteq Z(\tacc{4}{j})$
    \item $\Inf\tacc{8}{k}, \Inf\tacc{4}{j} \in D_{k}$
\end{itemize}
then we can we can substitute $\Inf\tacc{4}{j}$ with Boolean value $\true$. 
This modification does not change the language because it does not affect accepting runs of $S_{i}$. The transitions can create an accepting run that has the potential to satisfy $D_{k}$ only if they are labeled with both  $\tacc{8}{k}$  and $\tacc{4}{j}$. Since $Z(\tacc{8}{k}) \subseteq Z(\tacc{4}{j})$, one can notice that that if a run satisfies $\Inf\tacc{8}{k}$ then  $\Inf\tacc{4}{j}$ is satisfied as well. Therefore if we remove $\Inf \tacc{4}{j}$ from $\overline{\psi_{i}}$, this modification does not affect the language.

\subsubsection{$\Fin$ conjuncts\\}
Similarly as in previous section, this reduction is based on inclusion.
If following conditions hold:
\begin{itemize}
    \item $Z(\tacc{8}{k}) \subseteq Z(\tacc{4}{j})$
    \item $\Fin\tacc{8}{k}, \Fin\tacc{4}{j} \in D_{k}$
\end{itemize}
then we can we can substitute $\Fin\tacc{8}{k}$ with boolean value $\true$. This modification does not change the language because from if $\tacc{4}{j}$ is visited finitely often, then also $\tacc{8}{k}$ is visited finitely often. 
\medskip

We can merge two conjuncts into one if the conjuncts always occur in the same disjuncts in $\Fin$ form. We can do so regardless of the position of the acceptance marks that are contained in the conjuncts. 
If the following condition is met:
\begin{itemize}
    \item $\forall D_{k}: \Fin\tacc{8}{k} \in D_{k} \Longleftrightarrow \Fin\tacc{4}{j} \in D_{k}$
\end{itemize}
We introduce a fresh acceptance mark $\tacc{2}{l}$, such that $Z(\tacc{2}{l}) = Z(\tacc{8}{k}) \cup Z(\tacc{4}{j})$.
 Finally, we can update $D_{k}$:
\begin{align*}
    D_{k} = (D_{k} \setminus \{ \Fin\tacc{8}{k}, \Fin\tacc{4}{j} \}) \cup \{\Fin\tacc{2}{l}\}
\end{align*}

This update basically means that $\Fin\tacc{8}{k}, \Fin\tacc{4}{j}$ are substituted by $\true$ and new conjunct $\Fin\tacc{2}{l}$ is added to $D_{k}$. The acceptance mark $\tacc{2}{j}$ is placed on every edge of the SCC $S_{i}$ that is labeled with $\tacc{8}{k}$ or $\tacc{4}{j}$.
This modification does not change the language because it does not change the acceptance runs of $S_{i}$. It only relabels the acceptance marks on edges that can be seen finitely often. 



\subsubsection{$\Fin \land \Inf$ conjuncts\\}
There are two cases when we can reduce one of the pair of $\Inf\tacc{0}{i}$ and $\Fin\tacc{2}{l}$ conjuncts.

At first, if every transition labeled with  $\tacc{0}{i}$ is also labeled with $\tacc{2}{l}$, the conjunction of $\Inf\tacc{0}{i} \land \Fin\tacc{2}{l}$ is never $\true$ because every run that visits $\tacc{2}{l}$ also visits $\tacc{0}{i}$. Therefore we can reduce the whole disjunct $D_{k}$.
If the following conditions are met:
\begin{itemize}
    \item $Z(\tacc{0}{i}) \subseteq Z(\tacc{2}{l})$
    \item $\Inf\tacc{0}{i}, \Fin\tacc{2}{l} \in D_{k}$
\end{itemize}
We substitute the whole disjunct $D_{k}$ for $\false$. In other words $\overline{\psi_{i}} = \overline{\psi_{i}} \setminus \{D_{K}\}$.

Finally we can simplify $\overline{\psi_{i}}$, if the edges labeled with $\tacc{0}{i}$ and edges labeled with $\tacc{2}{l}$ are complementary.
More formally if:
\begin{itemize}
    \item  $\Inf\tacc{0}{i}$ and $\Fin\tacc{2}{l} \in D_{k}$
    \item $Z(\tacc{0}{i}) \cap Z(\tacc{2}{l}) = \emptyset \land Z(\tacc{0}{i}) \cup Z(\tacc{2}{l}) = \delta_{S_{i}} $
\end{itemize}
Then we can substitute $\true$ for $\Inf\tacc{0}{i}$.
This reduction does not change the language because if during a run of $S_{i}$ all transitions labeled with $\tacc{2}{l}$ are visited only finitely often, then necessarily at least one transition labeled with $\tacc{0}{i}$ is visited infinitely often. Therefore removing $\Inf\tacc{0}{i}$ from $\overline{\psi_{i}}$ does not affect the language, since the validity of $\Fin\tacc{2}{l}$ implies the validity of $\Inf\tacc{0}{i}$.

\subsection{Merge of $\psi_{i}$}
After applying reduction techniques from the previous section, each $S_{i}$ has its own acceptance condition $\psi_{i}$. The goal of this section is to merge these acceptance conditions into one formula $\psi'$ with emphasis on obtaining a formula with the minimal number of acceptance sets.

At first, the algorithm finds $\psi_{i}$ with the greatest number of disjuncts and states it as a base of the new acceptance condition $\psi'$. Now the algorithm continues by the successive merging of $\psi'$ with the unmerged formula $\psi_{i}$ that has the greatest number of disjuncts. This repeats until all formulae $\psi_{i}$ are merged. This process updates the form of $\psi'$ until it reaches its final form. The process of merging two formulae consists of two phases. In the first phase a suitable pairing of disjuncts is found and in the second phase, these disjuncts are merged.

\begin{enumerate}
	\item Let $\psi'$ denote the future acceptance condition of $\mathcal{A}'$ and $\psi_{i}$ is the acceptance condition of $S_{i}$ chosen to be merged. Then the algorithm uses \emph{linear sum assignment} to determine which disjunct of $\psi_{i}$ is merged with which disjunct of $\psi'$. The process of using \emph{linear sum assignment} and the pairing procedure is described in detail in work by T. Šťastná \cite{stastna.19.bc}.
    \item Let $D_{K} \in \overline{\psi_{i}}$ be a disjunct paired with $D_{L} \in \overline{\psi'}$. All conjuncts of $D_{L}$ are initially labeled as unused. Now the algorithm maps every conjunct $C_{k} \in D_{K}$ to a suitable conjunct $C_{l} \in D_{L}$ and labels $C_{l}$ as used. \footnote{The indexes differ to emphasize the fact that they are not equal.} A conjunct $C_{l}$ is suitable for $C_{k}$ is it is on the same type ($\Fin$ or $\Inf$), it is labeled as unused. If no suitable $C_{l}$ is found, the algorithm adds $C_{k}$ to disjunct $D_{L}$ and marks it as used.
\end{enumerate}


In an acceptance mark $m_{l} \in M$ occurs in $\psi'$ in more than one conjunct, we need to check whether all of these conjuncts are mapped to conjuncts form $\psi_{i}$ with the same acceptance mark $m_{k} \in M$. If not, we resolve this conflict by replacing all additional occurrences of $m_{l}$ with fresh acceptance mark $m_{n}$ and we place $m_{n}$ on the exact transition of $\mathcal{A}'$ where $m_{l}$ is placed.
Finally, in the end, the algorithm removes every acceptance mark that is not present in $\psi'$ from the edge of $\mathcal{A}$.

\medskip

\begin{example}
Consider $\overline{\psi'} =  \{ \{ \Fin\tacc{0}{0}, \Inf\tacc{1}{1} \} , \{\Fin\tacc{0}{0} \} \}$ \\ and $\overline{\psi_{i}} = \{  \{\Fin\tacc{4}{4} \}, \{ \Fin\tacc{2}{2}, \Inf\tacc{3}{3} \} \} $. We obtain the pairing $(1,2), (2,1)$, meaning that the first disjunct of $\overline{\psi_{i}}$ is merged wit the second disjunct of $\overline{\psi'}$ and second disjunct of $\overline{\psi_{i}}$ is merged with the first disjunct of $\overline{\psi'}$. Then $\Fin\tacc{0}{0}$ is mapped to $\Fin\tacc{2}{2}$, $\Inf\tacc{1}{1} $ is mapped to $\Inf\tacc{3}{3}$ and $\Fin\tacc{0}{0}$ is again mapped to $\Fin\tacc{4}{4}$ which causes a conflict. Therefore we need to replace the second occurrence of $\tacc{0}{0}$ with fresh mark $\tacc{5}{5}$. The set-representation of formula $\psi'$ after merging is $\psi' =  \{ \{ \Fin\tacc{0}{0}, \Inf\tacc{1}{1} \} , \{\Fin\tacc{5}{5} \} \}$.

\end{example}

Unfortunately, sometimes when the optimal mapping was not found, the procedure produces an automaton with a more complex acceptance condition than the acceptance condition of the input automaton. Therefore we propose and implement an optimization, which prevents such a behavior and in general, produces smaller acceptance condition than the original one.

\begin{itemize}
    \item The selection of base of $\psi'$ is based on two keys. The primary key is cardinality (number of clauses) of $\overline{\psi_{i}}$, the secondary key is cardinality of clauses (number of terms in clause).
    \item We order the disjunct in every $\overline{\psi_{i}}$ in descending order, where the key is the cardinality of a particular disjunct.
    \item The DNF conversion of the input acceptance condition can lead to an exponential blowup of the formula, where some acceptance marks occur more than once. Since the reduction of acceptance sets is basically denoting the redundant ones as $\true$ or $\false$, we can as well easily obtain simplified acceptance formula in CNF (we simply denote the same acceptance sets as $\true$ or $\false$ as we did in DNF). According to the shape of the input acceptance condition, we choose the suitable (shorter) normal form and perform the merging algorithm on it.
\end{itemize}
By choosing the CNF over DNF in the cases where CNF is more natural (shorter), we prevent the formula to contain some acceptance marks more than once (at least, we do not create them by conversion of $\psi$ to DNF). This way, we prevent adding new acceptance marks to the formula when resolving conflicts of acceptance marks which leads to better results. If the original formula contains an acceptance mark that is present in more than one disjunct, then by ordering the disjuncts in every $\overline{\psi_{i}}$, the \emph{linear sum assignment} returns more convenient pairing. Meaning that if \emph{linear sum assignment} finds two equal assignments, it respects the order and the disjuncts with the  acceptance mark that occurs more than once are paired with disjuncts that also contain acceptance mark that occurs more than once.

\begin{example}
	Consider an automaton $\mathcal{A}$ in Figure \ref{fig:L1_before}. In this example, we demonstrate the simplification procedure described in Section \ref{section:simplification} and obtain simplified acceptance conditions $\psi_{i}$ for each SCC $S_{i}$. The simplified acceptance conditions $\overline{\psi_{i}}$ are displayed in the set-format we introduced earlier because we make use of it afterward during the merge. Then we merge these formulae into the acceptance condition of the simplified automaton $\mathcal{A}'$.
We enumerate the SCCs $S_{1}, S_{2}, S_{3}$. (The indices correspond with the numbers inside the states in Figure \ref{fig:L1_before}.) And we assign an accepting condition $\psi_{1}$ to $S_{1}$, $\psi_{2}$ to $S_{2}$ and $\psi_{3}$ to $S_{3}$.
    \begin{enumerate}
	    \item We simplify $\psi_{1}$ according to the placement of acceptance marks on the edges in $S_{1}$. At first we notice, that the formula $\overline{\psi_{1}}$ contains acceptance marks that are not present on the edges of $S_{1}$. Therefore modify $\overline{\psi_{1}}$ as described in Subsection \ref{subsection:acc_modif}. We substitute $\true$ for $\Fin\tacc{3}{3}$ and $\false$ for $\Inf\tacc{1}{1}$ and $\Inf\tacc{0}{0}$. (This substitution deletes the whole disjunct $D_{1}$.) Then we notice that the acceptance marks are in a position which allows us to perform the simplification described in first part of subsection 3.1.4. We substitute $\true $ for $\Inf\tacc{4}{4}$ and obtain the final form of $\overline{\psi_{1}} = \{\{ \Fin\tacc{2}{2}\} \}$.
	    \item Similarly as in previous case, we notice that acceptance marks $\tacc{2}{2}$, $\tacc{3}{3}$ and $\tacc{4}{4}$ are not present on the edges of $S_{2}$. Therefore we substitute $\true$ for both $\Fin\tacc{2}{2} \text{ and } \Fin\tacc{3}{3}$ and $\false$ for $\Inf\tacc{4}{4}$ (and thus remove the whole disjunct $D_{2}$).  Then we use the procedure described in Subsection \ref{subsection:simpl_inf} and remove $\Inf\tacc{1}{1}$ from the disjunct $D_{1}$ and obtain $\overline{\psi_{2}} = \{ \{\Inf\tacc{0}{0}\} \}$.
        \item Finally, we yet again remove marks that are not present in $S_{3}$ and perform the simplification described in subsection 3.1.3. We substitute $\true $ for $\Fin\tacc{2}{2} \text{ and } \Fin\tacc{3}{3}$ and add new term $\Fin\tacc{5}{5}$ into $D_{2}$ and place $\tacc{5}{5}$ on the edges that are labeled with $\tacc{2}{2}$ or $\tacc{3}{3}$. The simplified acceptance condition is $\overline{\psi_{3}} = \{\{ \Fin\tacc{5}{5}, \Inf\tacc{4}{4}\}\}$.
    \end{enumerate}

	Now we proceed to the merge of the formulae of the SCCs $\psi_{i}$. As a base of the new acceptance condition $\psi'$ we choose the formula $\psi_{3}$ because it has the highest number of disjuncts compared to the other formulae $\psi_i$, so $\overline{\psi'}=\{ \{ \Fin\tacc{5}{5}, \Inf\tacc{4}{4} \}\}$. Now we merge  $\psi_{1}$ and $\psi_{2}$ with $\psi'$. The order is in this particular case irrelevant because $\overline{\psi_{1}}$ has the same number of disjuncts as $\overline{\psi_{2}}$ (and both disjuncts have the same number of conjuncts). So we merge $\overline{\psi_{1}}$ at first because of its lower index. Since both $\overline{\psi'}$ and $\overline{\psi_{1}}$ have only one disjunct, the only possible pairing that \emph{linear sum assignment 
    } can give us is $(0,0)$, meaning that $\{ \Fin\tacc{2}{2}\}$ is merged with $\{ \Fin\tacc{5}{5}, \Inf\tacc{4}{4}\}$. Then we need to map an unused conjunct  $\Fin\tacc{5}{5}$ to a conjunct of the same type which is $\Fin\tacc{2}{2}$. Similarly in case of $\overline{\psi_{2}}$ we map $\Inf\tacc{4}{4}$ on $\Inf\tacc{0}{0}$. This way we produce $\mathcal{A}'$ displayed in Figure  \ref{fig:L1_middle} with the acceptance condition $ \Fin\tacc{5}{5} \land \Inf\tacc{4}{4}$. Observe that the automaton $\mathcal{A}'$ is not equivalent to the original $\mathcal{A}$. For example in Figure \ref{fig:L1_middle} is the highlighted loop not accepting but in the original automaton in Figure \ref{fig:L1_before} the loop accepting is. To reach the equivalence between the two automata, we need to \emph{restore equivalence} which is described in the next section.
\end{example}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[automaton]
			\node[flabel] at (2,5) {$( \Inf\tacc{0}{0} \land \Inf\tacc{1}{1}) \lor (\Fin\tacc{2}{2} \land \Fin\tacc{3}{3} \land \Inf\tacc{4}{4})$};

			\node[state, initial] (x) at (0,0) {0};
			\node[state] (y) at (2,2) {1};
			\node[state] (z) at (2,-1.5) {2};
			\node[state] (w) at (5,-1.5) {3};

			\path[->]
				(x) edge[]  (y)
				(x) edge[]  (z)
				(z) edge[] (w)
				
            	
            	(z) edge[loop, in = 75, out = 105, looseness=6] (z)
            	(z) edge[loop, in = 72, out = 108, looseness=9] (z)
            	(z) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc1] {1}(z)
            	(z) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc0, pos=0.6] {0} node[accset,collacc1, pos=0.4] {1}(z)
            	
            	(w) edge[loop, in = 75, out = 105, looseness=6] (w)
            	(w) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc3] {3}(w)
            	(w) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc2] {2}(w)
            	(w) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4}(w)
            	
            	(y) edge[loop, in = 75, out = 105, looseness=6] node[accset,collacc4] {4}(y)
            	(y) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc4] {4}(y)
            	(y) edge[loop, in = 70, out = 110, looseness=12] node[accset,collacc2] {2} (y)
            	(y) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc2] {2}(y)
            	
            	
			;
		\end{tikzpicture}
    \caption{TELA before simplification Level 1}
    \label{fig:L1_before}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[automaton]
			\node[flabel] at (2,5) {$ \Fin\tacc{5}{5} \land \Inf\tacc{4}{4}$};

			\node[state, initial] (x) at (0,0) {0};
			\node[state] (y) at (2,2) {1};
			\node[state] (z) at (2,-1.5) {2};
			\node[state] (w) at (5,-1.5) {3};

			\path[->]
				(x) edge[]  (y)
				(x) edge[]  (z)
				(z) edge[] (w)
				
            	
            	(z) edge[loop, in = 75, out = 105, looseness=6] (z)
            	(z) edge[loop, in = 72, out = 108, looseness=9] (z)
            	(z) edge[loop, in = 70, out = 110, looseness=12]  (z)
            	(z) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4} (z)
            	
            	(w) edge[loop, in = 75, out = 105, looseness=6] (w)
            	(w) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4}(w)
            	
            	(y) edge[loop, in = 75, out = 105, looseness=6, color=red] (y)
            	(y) edge[loop, in = 72, out = 108, looseness=9] (y)
            	(y) edge[loop, in = 70, out = 110, looseness=12] node[accset,collacc5] {5} (y)
            	(y) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc5] {5}(y)
            	
            	
			;
		\end{tikzpicture}
    \caption{TELA after simplification and merging in Level 1}
    \label{fig:L1_middle}
\end{figure}

\subsection{Restoring equivalence}
Replacing the input acceptance condition with $\psi'$ in $\mathcal{A}$ might change the language, so it is no longer equivalent to the language recognized by the original automaton $\mathcal{A}$. 
 By now, each SCC $S_{i}$ is adjusted to the acceptance condition $\psi_{i}$ which might be different than $\psi'$. 
 Therefore, for each SCC we need to restore equivalence with the new acceptance condition $\psi'$.
 The idea is that the only terms of $\psi'$ that can affect accepting runs on SCC $S_{i}$ are the ones that have been mapped on some terms in $\psi_{i}$. From now on, we refer to them as \emph{used terms}. We need to make sure that the other terms (the ones that have not been mapped on any term of $\psi_{i}$) can't affect any accepting run of $\mathcal{A}'$. From now on, we call these terms \emph{unused terms}.  We influence the evaluation of the  \emph{unused terms} in the following way:
\begin{itemize}
     \item If we want to make term in the $\Fin$ form always $\false$, we place it's acceptance mark on every edge of the SCC.
     \item If we want to make term in the $\Inf$ form always $\true$, we place it's acceptance mark on every edge of the SCC.
\end{itemize}
 Keep in mind that by now, any acceptance mark that is not in $\psi'$ is not present on any edge of $\mathcal{A}'$. Therefore any $\Fin$ term is already always $\true$ if its acceptance mark is not present on any edge of the SCC. Dually, $\Inf$ term is already always $\false$ if it is not present on any edge of the SCC.
\medskip
 Now we distinguish the cases when $\psi'$ is in DNF or $\psi'$ is in CNF. 
\begin{itemize}
     \item If $\psi'$ is in DNF, we need to make $\false $ every disjunct that does not contain any \emph{used term}. Further, every \emph{unused term} that occurs in the same disjunct as any \emph{used term} needs to be made $\true$. 
     \item Dually, if $\psi'$ is in CNF, every conjunct that does not contain any \emph{used term} needs to be made $\true$ and every \emph{unused term} that occurs in a conjunct with any \emph{used term} needs to be made $\false$.  
     
\end{itemize}
 
\begin{example}
	Consider the example from the Figure \ref{fig:L1_middle}, where the DNF acceptance condition $\psi' = (\Fin\tacc{5}{5} \lor \Inf\tacc{4}{4})$ and the acceptance condition of SCC $S_{1}$ $\psi_{1} = (\Fin\tacc{2}{2})$. The term $\Fin\tacc{5}{5}$ is mapped to $\Fin\tacc{2}{2}$. Then we need to enforce that the \emph{unused term} $\Inf\tacc{4}{4}$ has no effect on the evaluation of $\psi'$ by the run with the infinite suffix contained within the SCC $S_{1}$. Otherwise the result will not be equivalent (see the highlited loop in Figure \ref{fig:L1_middle}). Therefore we make term $\Inf\tacc{4}{4}$ $\true$ by adding $\tacc{4}{4}$ on every edge of the SCC $S_{i}$. The result can be seen in Figure \ref{fig:L1_done}.
\end{example}
 

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[automaton]
			\node[flabel] at (2,5) {$ \Fin\tacc{5}{5} \land \Inf\tacc{4}{4}$};

			\node[state, initial] (x) at (0,0) {0};
			\node[state] (y) at (2,2) {1};
			\node[state] (z) at (2,-1.5) {2};
			\node[state] (w) at (5,-1.5) {3};

			\path[->]
				(x) edge[]  (y)
				(x) edge[]  (z)
				(z) edge[] (w)
				
            	
            	(z) edge[loop, in = 75, out = 105, looseness=6] (z)
            	(z) edge[loop, in = 72, out = 108, looseness=9] (z)
            	(z) edge[loop, in = 70, out = 110, looseness=12]  (z)
            	(z) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4} (z)
            	
            	(w) edge[loop, in = 75, out = 105, looseness=6] (w)
            	(w) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 70, out = 110, looseness=12]  node[accset,collacc5] {5}(w)
            	(w) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4] {4}(w)
            	
            	(y) edge[loop, in = 75, out = 105, looseness=6] node[accset,collacc4] {4} (y)
            	(y) edge[loop, in = 72, out = 108, looseness=9] node[accset,collacc4] {4}(y)
            	(y) edge[loop, in = 70, out = 110, looseness=12] node[accset,collacc4, pos=0.4] {4} node[accset,collacc5, pos=0.6] {5}(y)
            	(y) edge[loop, in = 65, out = 115, looseness=14] node[accset,collacc4, pos=0.4] {4} node[accset,collacc5, pos=0.6] {5}(y)
            	
            	
			;
		\end{tikzpicture}
    \caption{Equivalent TELA after simplification Level 1}
    \label{fig:L1_done}
\end{figure}

%}}}



%%% Local Variables:
%%% mode: latex
%%% End:
