MODULE maze(dir, wall, locked_gate, trap, stucked, trap_warn, rusting, drier, unl_g1, k1_found, unl_g2, k2_found, unl_g3, k3_found, charging)

-- TODO

DEFINE

 --maze := [0, 1, 2, 5, 6, 7, 8];
 K1 := 1;
 D := 2;
 --P := 5;
 G1 := 6;
 TR := 8;
 C := 7;
 SIZE := 8;
 r_position := robot_pos + 1;
 l_position := robot_pos - 1;
 
 
 VAR
 robot_pos : 0.. SIZE;
 puddle : {-1, 5};
 rusting_limit : {0, 1, 2, 3, 4};
 
 ASSIGN
 init(puddle) := 5;
init(trap) := FALSE;
init(stucked) := FALSE;
init(trap_warn) := FALSE;
init(rusting) := FALSE;
init(drier) := FALSE;

init(rusting_limit) := 4;


init(wall):= FALSE;
init(locked_gate) := FALSE;
init(unl_g1) := FALSE;

init(k1_found) := FALSE;

init(charging) := FALSE;

init(unl_g2) := FALSE;
init(unl_g3) := FALSE;
init(k2_found) := FALSE;
init(k3_found) := FALSE;
next(k2_found) := FALSE;
next(k3_found) := FALSE;
next(unl_g2) := FALSE;
next(unl_g3) := FALSE;
 
 init(robot_pos) := 0; 
 
 
next(charging):= case
		next(robot_pos) = C : TRUE;
		TRUE: FALSE;
		esac;
 
next(stucked) := case
		  stucked : TRUE;
		  (rusting_limit) = 1 & ((robot_pos) = D) : FALSE;
		  (rusting_limit) = 1 & ((robot_pos) != D) : TRUE;
		  next(rusting_limit) = 0 : TRUE;
		  TRUE : FALSE;
		  esac;

 
 next(drier) := case
 		next(robot_pos) = D : TRUE;
 		TRUE : FALSE;
 		esac;
 		
 
 next(rusting_limit):= case
 			next(drier) : 4;
 			rusting & (rusting_limit != 0) : rusting_limit -1;
 			
 			TRUE : rusting_limit;
 			esac;
 			
 
 
 next(rusting) := case
 		   next(drier) : FALSE;
 		   next(robot_pos) = puddle : TRUE;
 		   rusting & !drier : TRUE;
 		   
 		   TRUE : FALSE;
 		   esac;
 		   
 
 next(puddle) := case 
 		  robot_pos = puddle : -1;
 		  TRUE: puddle;
 		  esac;
 
 next(robot_pos) := case
 		    next(trap) : robot_pos;
 		    trap_warn : robot_pos;
 		    rusting_limit = 1 & robot_pos != D: robot_pos;
 		    stucked : robot_pos;
 		    --dir = r & robot_pos < SIZE : robot_pos;
 		    next(locked_gate) : robot_pos;
 		    robot_pos < SIZE  & !next(locked_gate) & (dir = r) : r_position;
 		    robot_pos > 0 & !next(locked_gate) & (dir = l): l_position;
 		    TRUE: robot_pos;
 		    
 		    esac;
 
 
 
 next(trap_warn) := case
 		next(robot_pos) = TR : TRUE;
 		trap_warn : TRUE;
 		TRUE : FALSE;
 		esac;
 		
 next(trap) := case
 		trap_warn : TRUE;
 		trap : TRUE;
 		TRUE : FALSE;
 		esac;
 
 
 next(wall) := case
	      dir = u | dir = d | (dir = l & robot_pos = 0)
	       | (dir = r & robot_pos = SIZE) : TRUE;
	       TRUE : FALSE;
	       
	       esac;
	     
next(locked_gate) := case
		      ( dir = r &  (r_position = G1 & !k1_found ))
		       |
		       ( dir = l &  (robot_pos - 1 = G1 & !k1_found )) : TRUE;
		       
		       TRUE : FALSE;
		       esac;
		       
next(k1_found):= case
		k1_found : TRUE;
		next(robot_pos) = K1 : TRUE;
		TRUE : FALSE;
		esac;
		
next(unl_g1) := case
		next(robot_pos) = G1 : TRUE;
		TRUE : FALSE;
		esac;
		
